## Netty出站与入站机制
### 入站与出站
- `ChannelPipeline`提供了`ChannelHandler`链的容器。以客户端应用程序为例，如果事件的运动方向是从客户端到服务器端，则称这些事件为出站，即客户端发送给服务器的数据会通过`pipeline`中的一系列`ChannelOutboundHandler`，并被这些`Handler`处理。反之称为入站

## Netty的handler调用机制
### 案例
- 使用自定义的编码器和解码器来说明`Netty`的handler调用机制
- 客户端发送long->服务器，服务器发送long->客户端

### 结论

## TCP粘包拆包
### 基本介绍
- TCP是面向连接、面向流的，提供高可靠性服务。收发两端都要有成对的`socket`，因此，发送端为了将多个发送给接收端的包，更有效的发给对方，使用了优化方法（Nagle算法），将多个间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包，这样做虽然提高了效率，但是接收端难于分辨出完成的数据包，因为面向流的通信是无消息保护边界的。
- 由于TCP无消息保护边界，需要在接收端处理消息边界问题，也就是粘包拆包。
- 看图
![[截屏2021-12-08 下午7.11.11.png]]
 ### TCP拆包粘包实例
 
 ### 自定义协议解决TCP粘包拆包
 - 使用自定义协议+编解码器解决
 - 关键是解决服务器端每次读取数据长度的问题
 - 实例
	 - 要求客户端发送5个`Message`对象，客户端每次发送一个`Message`对象
	 - 服务器端每次接收一个`Message`，分5次进行解码，每读到一个`Message`，就会回复一个`Message`对象给客户端