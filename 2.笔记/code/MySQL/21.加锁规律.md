基于可重复读隔离级别，5.7<MySQL版本<8.0
#### 加锁规则--两个原则两个优化1个bug
1. 原则1：加锁的基本单位是临键锁
2. 原则2：查找过程中访问到的对象才会加锁。
3. 优化1：索引的等值查询，给唯一索引加锁的时候，临键锁退化为行锁
4. 优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件时，临键锁退化为间隙锁
5. 一个bug：唯一索引上的范围查询会访问到第一个不满足条件的第一个值为止

```
CREATE TABLE `t` (
`id` int(11) NOT NULL,
`c` int(11) DEFAULT NULL,
`d` int(11) DEFAULT NULL,
PRIMARY KEY (`id`),
KEY `c` (`c`)
) ENGINE=InnoDB;

insert into t values(0,0,0),(5,5,5),
(10,10,10),(15,15,15),(20,20,20),(25,25,25);
```

#### 等值查询间隙锁
![[加锁规则--等值查询间隙锁.png]]
1. 根据原则1，加锁单位是临键锁(5,10]
2. 同时根据优化2，这是一个等值查询，id=10不满足查询条件，临键锁退化为间隙锁(5, 10)
因此sessionB插入id=8会被锁住，但是sessionC可以修改id=10这一行。

#### 非唯一索引等值锁
![[加锁规则-只加在非唯一索引的锁.png]]
1. 根据原则1，加锁单位是临键锁，因此会给(0,5]加上临键锁
2. c是普通索引，因此仅访问c=5这一条是不能马上停下来的（唯一键会停），需要向右遍历，查到c=10才放弃，根据原则2，访问到的都要加锁，因此要给(5,10]加临键锁
3. 但是同时满足优化2，等值判断，向右遍历，最后一个不满足c=5这个等值条件，因此退化成间隙锁(5,10)
4. 根据原则2，只有访问到是的对象才会加锁，这个查询使用覆盖索引，不需要访问主键索引，所以主键索引没有加任何锁，这也是为什么sessionB的update可以执行完成。

但是sessionC要插入一个(7,7,7)的记录，就会被sessionA的间隙(5,10)锁住。
注意lock in share mode只锁覆盖索引，如果是for update会顺便给主键索引上满足条件的行加锁。

#### 主键索引范围锁
下面两个语句加锁范围是等价的吗？
```
select * from t where id=10 for update
select * from t where id>=10 and id<11 for update
```
第二条语句执行情况
![[加锁规则-主键索引上范围查询的锁.png]]
1. 开始执行时，要找到第一个id=10的行，因此是临键锁(5,10]。根据优化1，主键id上等值条件，退化成行锁，只加了id=10这一行的锁
2. 范围查找往后继续，找到id=15停下来，加临键锁(10，15]
此时sessionA锁的范围就是主键索引上，行锁id=10和临键锁(10, 15]

#### 非唯一索引范围锁
![[加锁规则-非唯一索引范围锁.png]]
第一次用c字段定位记录时，索引c上加了(5，10]这个临键锁，由于索引c是非唯一索引，没有优化规则，不会退为行锁，因此sessionA加的锁时(5,10]和(10,15]这两个临键锁

#### 唯一索引范围锁bug
![[加锁规则-唯一索引范围锁的bug.png]]
临键锁范围是(10,15]和(15,20]

#### 非唯一索引上存在等值的例子
插入一条记录`insert into t value(30, 10, 30)`
此时索引c上的间隙状态为：
![[加锁规则-非唯一索引等值的例子.png]]
delete加锁的逻辑和`select for update`是类似的。
![[加锁规则-delete示例.png]]
先访问第一个c=10的记录，根据原则1有临键锁(5,10]，接着向右查找，碰到c=15这个记录根据原则2有间隙锁(10,15]。根据优化2，这是个等值查询，且是非唯一索引，退化成(10,15)间隙锁。

#### 案例七：limit语句加锁
![[加锁规则-limit语句加锁.png]]
此时与上面的delete加锁不同，虽然删除的效果一样。
访问第一个c=10的记录，有临键锁(5,10]，因为c=10有两条记录，因此不会向右继续查找。所以此时只有临键锁(c=5,id=5)到(c=10,id=30)
![[加锁规则-带limit2的加锁效果.png]]
这里我们可以看出，在删除数据的时候尽量加limit，这样不仅可以控制删除数据的条数，还可以减小加锁的范围。

#### 一个死锁的例子
![[加锁规则-案例八的操作序列.png]]
1. sessionA启动事务后执行查询语句加lock in share mode，在索引c上加了临键锁(5,10]和（10，15）
2. sessionB的update语句也要在索引c上加临键锁(5,10]进入锁等待
3. sessionA要插入(8,8,8)被sessionB锁住。出现死锁，此时InnoDB让sessionB回滚。

sessionB的临键锁不是在申请吗？
sessionB加临键锁(5,10]实际上分两部，先加(5,10)的间隙锁，加锁成功，再加c=10的行锁，此时才被锁住。