如果备库执行日志的速度持续低于主库生成日志的速度，这个延迟就可能成了小时级别。![[主备流程图.png]]
`sql_thread`拆成多个线程
![[主备复制-多线程模型.png]]
`coordinator`就是原来的`sql_thread`，不过它现在不直接更新数据，只负责读取中转日志和分发事务。真正更新日志的是`work`线程。线程个数由参数`slave_parallel_workers`决定，一般设置为8-16之间最好（32核物理机）
能不能轮训分发给work？不能。因为cpu的调度可能导致第二个事务比第一个事务先执行。
同一个事务的多个更新语句，能不能分给不同的worker执行？不行。假如一个事务更新了表t1和t2的各一行，如果这两条更新语句被分到不同的worker，虽然最终的结果是主备一致的，但如果表t1执行完成的瞬间，备库有个查询，就会看到这个事务更新了一半的结果。
因此，`coordinator`在分发时，需要满足两个基本要求：
1. 不能造成更新覆盖。这要求更新同一行的两个事务，必须被分发到同一个worker中。
2. 同一个事务不能被拆开，必须放在同一个worker中。

#### MySQL5.5版本的并行复制策略
5.5版本不支持并行策略。
别人自己写的两个并行策略
##### 按表分发策略
思路：如果两个事务更新不同的表，则可以并行。按表分发，可以保证两个worker不会更新同一行。
每个worker线程对应一个hash表，用于保存当前正在这个worker的执行队列里的事务所涉及的表。hash表的key是库名.表名，value为一个数字，表示这个队列中有多少个事务修改这个表。
假设一个新事务T，这个修改的行涉及到表t1和t3。看一下流程：
1. 由于事务T涉及表t1，而worker_1队列中有事务在修改t1，事务T和队列中某个事务要修改同一个表的数据，这种情况我们称事务和worker_1冲突。
2. 顺序判断事务T和每个worker队列的冲突情况。
3. 事务T跟多于1个worker冲突，`coordinator`线程进入等待。
4. 每个worker继续执行，同时修改hash_table。假设hash_table_2中设计到修改表t3的事务先执行，此时从hash_table_2中去除。
5. 此时事务T只与一个worker冲突，就将其分配给这个worker
6. `coordinator`继续读下一个中转日志，继续分配事务。

因此，每个事务在分发时，有三种情况：
1. 跟所有worker不冲突，此时把事务分配给最空闲的worker
2. 跟多于一个worker冲突，`coordinator`进入等待，直到跟这个事务冲突的worker只剩1个
3. 只跟一个worker冲突，把这个事务分配给这个存在冲突的worker。

在多个表负载均衡的场景中效果很好，但是碰到热点表，比如所有的更新事务都设计到某一个表时，就会变成单线程复制。

##### 按行分发策略
思路：如果两个事务没有更新相同的行，它们在备库上可以按行执行。这个模式需要binlog是row。
此时我们判断一个事务T与worker是否冲突，判断的是是否修改同一行。
也是为每一个worker建立一个hash表，key是库名+表名+唯一键的值+索引。

#### 5.6版本的并行复制策略
支持粒度为按库并行。

#### MariaDB的并行复制策略
MariaDB利用了组提交的特性：
1. 能够在同一组提交的事务，一定不会修改同一行
2. 主库可以并行执行的事务，在备库上一定可以并行执行。

MariaDB的并行复制流程：
1. 在一组里面提交的事务，有一个相同的commit_id，下一组是commit_id+1
2. commit_id直接写到binlog
3. 传到备库应用的时候，相同的commit_id的事务分发到多个worker执行
4. 一组执行完成后，再去取下一批。

会被大事务拖后腿。

#### 5.7的并行复制策略
参数`slave_parallel_type`控制并行复制策略
1. 配置为DATABSAE,表示使用5.6的按库并行策略。
2. 配置为LOGICAL_CLOCK，表示的就是类似Maria的策略。MySQL进行了优化。

MariaDB是commit的事务可以提交。实际上，只要能够到达`redo log prepare`阶段，就表示事务已经通过锁冲突的检验了。
MySQL5.7并行复制策略的思路是：
1. 同时处于`prepare`状态的事务，在备库执行是可以并行的。
2. 处于`prepare`状态的事务和处于`commit`状态的事务之间，在备库执行时也是可以并行的。

#### 5.7.22的并行复制策略
新增一个新的并行复制策略，基于WRITESET的并行复制。
相应的新增一个参数`binlog-transaction-dependency-tracking`来控制是否开启这个新策略，有三个可选值：
1. COMMIT_ORDER，根据同时进入prepare和commit来判断是否可以并行的策略
2. WRITESET。表示对于事务涉及更新的每一行，计算出这一行的hash值，组成集合writeset。如果两个事务没有操作相同的行，也就是它们的writeset没有交集，就可以并行。
3. WRITE_SESSION，在WRITESET上多了一个约束，即在主库上同一个线程先后执行的两个事务，在备库执行时，要保证相同的先后顺序。

MySQL进行的优化：
1. writeset在主库生成后直接写入binlog，不需要备库计算解析。
2. 不需要把整个事务的binlog都扫一面才决定分发到哪个worker
3. 由于备库的分发策略不依赖与binlog内容，因此binlog的格式是statement也是可以的。

