#### count(*)的实现方式
不同的引擎有不同的实现方式
- MyISAM把一个表的总行数存在了磁盘，因此每次执行会直接返回这个数，效率很高。(讨论在不加过滤条件时)
- InnoDB需要把数据一行一行地从引擎读出来，然后累计计数。
- 为什么InnoDB这么设计
    - 因为MVCC的原因，InnoDB表应该返回多少行是不确定的。因为事务的隔离级别是可重复读，因此每一行记录都要判断自己是否对这个会话可见，因此需要将每一行都读出来判断。
 - 总结
     - MyISAM快，但是不支持事务
     - InnoDB准确，但是会导致性能问题
     - show table status快，有table_rows字段，但是不准确，table_rows也是根据采样估算得来的。
  - 实际业务中，我们只能自己计数
      - 基本思路：找一个地方，把操作记录表的行数存起来。
      - 用缓存系统保存计数
          - redis保存，每插入一行计数+1，删除一行计数-1。可能会丢失更新。--很不准确
      - 在数据库保存计数
          - 解决了崩溃丢失的问题，InnoDB支持崩溃恢复不丢数据。 
#### count的几种用法的性能差别
- count()的语义：聚合函数，对于返回的结果集一行行判断，如果函数的参数不是NULL,累计值就加1，否则不加，最后返回累计值。
- 因此count(*) count(主键id)count(1)都表示返回满足条件的结果集的总行数。而count(字段)则表示返回满足条件的数据行里面，参数字段不为null的总个数
- 分析性能差异时，有几个原则
    - Server层要什么给什么
    - InnoDB只给必要的值。
    - 优化器只优化了count(*)的语义为取行数，其他显而易见的优化并没有做。
        - 对于count（主键id）来说，InnoDB会遍历整张表，把每一行的id都取出来，返回给server层，server层拿到id后，判断是不可能为空的，按行累加
        - 对于count(1)来说，遍历整张表，但是不取值。server层对返回的每一行，放一个数字1进去，判断不可能为空，按行累加
        - 对于count(字段)来说：如果字段定义是not null时，一行行读出这个字段，判断不能为null，按行累加；定义为null，执行的时候有可能是null，因此还要把值取出来判断一下，不是null累加。
        - count(*)例外，并不把全部字段取出来，而是专门做了优化，不取值。count(*)肯定不是null，按行累加。
        - 按效率排序：count(字段) <count（主键id）<count(1)约等于count(*)

#### MySQL为什么这么设计

#### 应用中有频繁变更并需要统计表行数，业务该如何设计