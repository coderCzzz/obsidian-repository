## 什么是事务？事务的隔离级别有哪些？
事务是指一组操作满足以下条件：
- 这一组操作要么全部成功，要么全部失败。
- 要么对数据库全部产生影响，要么都不产生影响

事务的隔离级别有4种，分别是
- 读未提交
- 读已提交
- 可重复读
- 串行化
## 每个隔离级别分别会引发哪些问题，MySQL默认在哪个隔离级别？
- 读未提交：指一个事务还未提交时，另一个事务就可以读到未提交的事务中的数据。如在一个事务A中改变了一个值，此时另一个事务B读到了改变后的值，但是A又做了回滚，此时就会造成B读取的数据不正确，也就是造成**脏读**。
- 读已提交：指一个事务B只能读到事务A提交后的数据。如事务A提交前的数据1，提交后的数据是2，此时事务B读取的就是2。但是如果事务A多次修改提交值，就会造成事务B每次读取的值不一致，也就是会造成**不可重复读**的问题。
- 可重复读：指事务A在事务过程中每次读取的值都是一致的。可重复读会造成幻读。幻读也是每次读取的数据不一致。（innodb下解决）
- 串行化：完美解决，随之而来的是效率降低。

MySQL默认情况下是读已提交级别。


## 事务的ACID特性？实现原理是什么？
- ACID

1. 原子性：事务中的所有操作作为一个整体像原子一样不可分割，要么全部成功,要么全部失败
2. 一致性:事务的执行结果必须使数据库从一个一致性状态到另一个一致性状态
3. 隔离性:并发执行的事务不会相互影响,其对数据库的影响和它们串行执行时一样。比如多个用户同时往一个账户转账,最后账户的结果应该和他们按先后次序转账的结果一样。
4. 持久性：事务一旦提交,其对数据库的更新就是持久的。任何事务或系统故障都不会导致数据丢失。

### 原子性实现原理--undolog
- 在操作任何数据之前，都会把之前的数据保存到一个地方--undolog，然后再进行数据修改。这样如果需要回滚就可以利用undolog将数据回滚到事务之前的状态。
- undolog是逻辑日志。让你插入一条数据，它就会记录一条delete语句，也就是相反的语句。

### 持久性实现原理--redolog与binlog
redo log保证宕机恢复内存里的记录。binlog恢复已提交的数据。
[[4.redo log与binlog]]

### 隔离性实现--undolog与MVCC
#### 前置知识
##### 当前读和快照读
1. 当前读：读取的是数据最新版本，总是读取到最新的数据。

```
select .......lock in share mode加读锁 
select....for update。
update delete insert操作
```
2. 快照读：读取的是历史版本的记录。也就是普通的select。

##### 基于undolog的版本链
3. 隐藏字段  每一行记录上都会包含几个用户不可见字段
-   DB_TRX_ID--创建或者最后一次修改该记录的事务id
-   DB_ROW_ID--隐藏主键
-   DB_ROLL_PTR--回滚指针：指向上一个历史记录。与undolog配合使用
undolog回滚日志：保存历史版本状态
![[版本链.png]]
注意：无论事务是否提交，只要执行了更新或插入语句，都会记录到版本链中。
最原始插入时，TRX_ID和DB_ROLL_PTR都为null。
版本链不是被立即删除的，而是在确定没有其他事务引用对应时，才进行删除。
4. readview--事务在进行**快照读**的时候，MVCC提取数据的依据，也就是依据这个和版本链决定读取版本链中哪个版本的数据。
包含了
-  m_ids :系统活跃的事务id
-   min_trx_id: 列表中事务最小的id
-   max_trx_id： 系统尚未分配的下一个事务id，也就是最大事务id+1
- creator_trx_id:ReadView创建者的事务编号
readview生成的时机是不同的。
RC:每次在进行快照读的时候都会生成新的ReadView
RR：只有在第一次进行快照读的时候才会生成Readview,之后的读操作都会用第一次生成的readview
读未提交下：直接返回最新值
串行化：通过加锁避免并行化

#### 原理
当不同的事务对同一条记录做修改的时候，会导致该记录的undolog形成一个线程表，也就是链表，链表的链首是最新的历史记录，而链尾是最早的历史记录。
那么新的查询过来，读取的是哪个记录？看可见性判断规则。
新的查询过来，会生成ReadView。
RC:每次在进行快照读的时候都会生成新的ReadView
RR：只有在第一次进行快照读的时候才会生成Readview,之后的读操作都会用第一次生成的readview
判断规则：
将每一个版本链的trx_id代入，与ReadView对比，判断。
先判断trx_id是否等于creator_trx_id，如果相等，说明这个数据就是自己更改的，则可以访问。
判断trx_id < min_trx_id，如果成立，说明事务已经提交，可以访问。
判断trx_id >max_trx_id，说明事务是创建ReadView后才开启的，不允许访问。
判断 trx_id >=min_trx_id && trx_id <=max_trx_id,符合的话，进一步判断trx_id是否存在于m_ids中，存在则说明未提交，不允许访问。不存在说明已提交，允许访问。(m_ids是活跃事务列表，也就是未提交事务)

##### RC下
- RC下的ReadView
RC:每次在进行快照读的时候都会生成新的ReadView
![[RC下的ReadView.png]]![[RC下的数据提取.png]]

- RC下的数据提取。
![[RC下的数据提取.png]]

##### RR下
- 规则类似，注意RR下只有第一次才生成ReadView，后面的查询会复用ReadView，因此也就实现了可重复读
- RR下使用MVCC能完全避免幻读吗？能，但不完全能。
连续快照读的时候，可以避免幻读。
在两次快照读之间存在当前读，ReadView会重新生成，就有可能造成幻读。
5.5以后 mvcc遇到带有当前读的情况也会上锁了，一上锁就不存在幻读和不可重复读