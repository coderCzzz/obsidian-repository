自增主键不能保证连续递增，注意是连续递增。它依然是递增的，可以避免页分裂。
```
CREATE TABLE `t` (

`id` int(11) NOT NULL AUTO_INCREMENT,

`c` int(11) DEFAULT NULL,

`d` int(11) DEFAULT NULL,

PRIMARY KEY (`id`),

UNIQUE KEY `c` (`c`)

) ENGINE=InnoDB;
```

#### 自增值保存在哪
表结构定义存放在后缀名为.frm的文件中，但是不会保存自增值。
不同的引擎对自增值的保存策略不同。
- MyISAM的自增值保存在数据文件中
- InnoDB引擎的自增值，保存在内存中，到了8.0版本，才有自增值持久化的能力，也就是重启后，表的自增值可以恢复为MySQL重启前的值。
    - 5.7及之前的版本，自增值保存在内存里，并没有持久化。每次重启后，第一次打开表，都会去找自增值的最大值max(id)，然后+1作为这个表的当前自增值
    - 8.0，将自增值的变更记录记录在redo log，重启时依靠redo log恢复之前的值。


#### 自增值修改机制
如果字段id被定义为自增，在插入一行数据的时候，自增值的行为如下：
1. 如果插入数据时id指定为0,null，或未指定值，就把这个表当前的`AUTO_INCREMENT`值填到自增字段
2. 如果插入数据时指定了具体的值，就直接使用语句里面指定的值。

自增值的变化：
假如要插入的值是X，当前自增值是Y
1. 如果X<Y,那么这个表的自增值不变
2. 如果X>=Y,就把当前的自增值修改为新的自增值

新的自增值生成算法：从`auto_increment_offset`开始，以`auto_increment_increment`为步长，持续叠加，直到找到第一个大于X的值，作为新的自增值。

`auto_increment_offset`和`auto_increment_increment`是连个系统参数，分别表示自增的初始值和步长，默认都是1
备注：在双M的主备结构要求双写时，我们会设置`auto_increment_increment=2`，让一个库的自增id都是奇数，另一个自增id是偶数，避免两个库生成的主键发生冲突。

#### 自增值的修改时机
假设表中已经有(1,,1,1)的记录，此时再插入一条数据
```
insert into t values(null, 1, 1); 
```
执行流程：
1. 执行器调用InnoDB引擎写入一行，传入的是(null,1,1)
2. InnoDB发现没有指定自增id的值，获取表t当前的自增值2
3. 将传入的行的值改为（2，1，1）
4. 将表的自增值该为3
5. 继续执行插入数据，由于已经存在c=1的记录，报`Duplicate key error`，语句返回。

没有插入成功，但是也没有将自增值修改回去。下次再插入新的数据行，拿到的自增id就是3，也就是出现了自增主键不连续的情况。
**唯一键冲突是导致自增主键id不连续的第一种原因**
**事务回滚也会产生类似的现象，这就是第二种原因**