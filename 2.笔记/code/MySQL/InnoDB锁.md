## 什么是锁
- 锁是一种机制，要来管理对共享资源的并发访问。

## 锁分类
- 共享锁、排他锁
- 意向锁
- 记录锁
- 间隙锁
- 临键锁
- 插入意向锁
- 自增锁
- 谓词锁

## 共享锁和排他锁
- 两种行锁：共享锁s和排他锁x
	- 共享锁允许持有该锁的事务读取一行
	- 排他锁允许持有该锁的事务修改、删除一行
- 如果事务T1持有持有R行的共享锁，另一个事务T2请求行R的锁
	- 如果T2请求S锁，可以授予给T2. 事务T1、T2都持有行R的S锁。
	- 如果T2请求R行的X锁，则不能获得。
- 如果一个事务T1持有某行R的X锁，则另一个事务无论请求什么锁都无法获得，必须等待事务T1将行R的X锁释放
- 查询语句默认不加锁。加排他锁使用`select for update`，共享锁加`select lock in share mode`。修改、插入、删除自动给涉及的数据加排他锁。
- 加X或S时，数据库会自动对应意向锁。

## 意向锁
- InnoDB支持多粒度锁来允许行锁和表锁共存。
- 意向锁是一种表锁：指示一行在稍后事务需要哪种行锁。
	- 意向共享锁IS:表明事务想要给行设置共享锁S
	- 意向排他锁IX：表明事务想要给行设置排他锁X
- 意向锁协议如下：
	- 事务可以获取共享锁（排他锁）之前，必须先获取对应的意向共享锁（排他锁）
- 一个锁可以被授予给请求该锁的事务需要满足：这个锁和已经存在的锁兼容。因为授予了会导致死锁。
- 表级锁之间的兼容关系：这里的S X指表级别的共享锁和排他锁![[截屏2021-11-20 上午8.55.16.png]]
- 除了全表请求（如`LOCK TABLES WHERE`），意向锁不会锁定任何东西。意向锁的目的是显示某行已经被锁定或将要被锁定。

#### 为什么意向锁能实现不同级别的锁共存
> 考虑这样一个例子：
1 事务A给某行加S锁，即这行只能读不能写。
2 之后，事务B申请整个表的写锁。如果它申请成功，就可以对表内所有行修改。就会与A持有的行锁冲突
3 要解决这个冲突，就需要判断表中每一行是否有被行锁锁定，如果被锁定，就不允许加表锁。--但是这种判断方法效率不高。 
- 有了意向锁之后，再加行锁需要先加意向锁。意向锁表明了对应的表有行锁或即将有加锁的，就不用遍历判断了。
- 意向锁即存在行锁场景下的表锁快速失败机制
- IX IS是表级锁，不会和行级的X锁S锁发生冲突，只会和表级别的X、S锁冲突

## 记录锁
- 用于索引记录的锁。如`SELECT FROM WHERE FOR UPDATE`
- 防止其他事务对一行进行修改、删除、插入。

## 间隙锁
- 间隙锁：在索引记录之间或在第一个记录之前最后一个记录之后的锁。
- 允许不同事务在间隙上持有冲突的锁
- 唯一目的是防止其他事务插入间隙。间隙锁可以共存。
- 间隙锁可以被禁止，

## 不同事务隔离级别采用不同的加锁机制
- 可重复读RR
	- 一致性非锁定读取--使用第一次读出的快照，即普通select
	- 锁定读取：for update lock share in mode修改删除
		- 对于具有唯一搜索条件的唯一索引，只锁定找到的索引记录，不锁定间隙
		- 对于其他条件，使用间隙锁或临键锁
- 读已提交RC
	- 一致性非锁定读：每次读取新快照
	- 锁定读：
		- 只锁定索引记录，不锁定间隙，间隙锁只用于外键约束检查和重复键检查
		- 间隙锁被禁用，可能出现幻读