#### join语句是怎么执行的
有两个表，都有一个主键索引id和一个索引a，字段b上无索引。t2中有1000行数据，t1中有100行数据。

##### 使用被驱动表索引的情况
```
select * from t1 straight_join t2 on (t1.a=t2.a);
```
`straight_join`避免使用优化器，让MySQL使用固定的连接方式执行查询，t1是驱动表，t2是被驱动表。
![[截屏2021-10-25 上午9.32.37.png]]
被驱动表t2字段a有索引，join过程使用了该索引。
该语句执行流程：
1. 从表t1读入一行数据R
2. 从数据行R中，取a字段到表t2里去查找
3. 取出表t2中满足条件的行，跟R组成一行，作为结果集的一部分
4. 重复执行13，直到表t1的末尾循环结束

该过程称为Index Nested-Loop Join，简称NLJ。
该过程中：
1. 对驱动表t1做了全表扫描，这个过程需要扫描100行
2. 对于每一行R，根据a字段去表t2查找，走的是搜索树过程，由于我们构造的数据是一一对应的，因此每次搜索也扫描一行，总共扫描100
3. 整个执行过程扫描200行。

不使用join时：循环表t1的数据R，执行`select * from t2 where a=$R.a`,把返回的结果和R构成结果集的一行。此时也是扫描了200行，但是共执行了101条语句，客户端还需要自己拼接SQL语句和结果。

##### 不使用被驱动表索引的情况
```
select * from t1 straight_join t2 on (t1.a=t2.b);
```
由于表t2的字段b上没有索引，每次到t2匹配的时候，都要做一次全表扫描。
继续使用类似上面的算法，也是可以得到正确的结论，该算法的名字叫`Simple Nested-Loop Join`
此时，SQL请求要扫描的行数是100×1000=10万行
实际上MySQL使用了BNL算法（Block Nested-Loop Join）

##### Block Nested-Loop Join
被驱动表上没有可用的索引，算法的流程是这样的：
1. 把表t1的数据读入线程内存`join_buffer`中，由于我们这个语句中写的是`select *`,因此是把整个表t1放进了内存
2. 扫描表t2，把表t2的每一行取出来，跟`join_buffer`中的数据做对比，满足join条件的，作为结果集的一部分返回。

实际上，该算法也是扫描10w行，但是这10w次判断是内存操作，速度会快很多，性能会更好。


#### 使用join有什么问题

#### 如果有两个大小不同的表做join，应该用哪个表做驱动表
- 可以使用被驱动表索引
在join过程中，驱动表走全表扫描，被驱动表走树搜索。
假设被驱动表的行数是M。每次被驱动表查一行数据，先搜索索引a，再搜索主键索引。搜索一棵树的时间复杂度是log2M，一行就是2×log2M
假设驱动表的行数是N，执行过程要全表扫描，然后到被驱动表匹配，因此整个过程是N+N×2×log2M
显然N对扫描行数的影响更大，因此应该让小表驱动大表。

- 不能使用被驱动表的索引
假设小表的行数是N，大表的行数是M，在这个算法里：
1. 两个表都要全表扫描，总扫描行数是M+N
2. 内存中的判断次数是M×N

此时可以看出M和N交换顺序没有影响，因此此时耗时一样。
如果t1较大，`join_buffer`放不下，就会分块放。
假设分K段,也即是K次算法执行完成，p×N=K,则扫描行数是N+p×N×M
,此时可以看出N小些较好，也即是小表驱动大表


#### 结论
在可以使用被驱动表的索引时
1. 使用join语句，性能比强行拆成多个单表执行SQL语句的性能更好，也就是使用了` Index Nested-Loop Join`算法
2. 小表做驱动表

在不可以使用被驱动表的索引时
1. 尽量不要用。也就是使用了`Block Nested-Loop Join`
2. `join_buffer_size`足够大时，一样
3. `join_buffer_size`不够大时，小表驱动大表

怎么定义小表？
在决定哪个表做驱动表时，应该是两个表按照各自的条件过滤，过滤完成后，计算参与join的各个字段的总数据量，数据量小的那个表，就是小表。
