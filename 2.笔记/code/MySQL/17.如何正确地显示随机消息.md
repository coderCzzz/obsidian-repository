从一个单词表中随机选出三个单词该如何写SQL

#### 内存临时表
```
select word from words order by rand() limit 3
```
分析一下该SQL会发现需要使用内存临时表且执行排序操作。
我们知道排序有两种算法：全字段排序和rowid排序。此时数据在内存中，回表不会造成多访问磁盘，因此基于用于排序的行越小越好，MySQL此时选择rowid排序。
##### 分析该语句扫描行数
假设数据共10000行。这条语句的执行流程为：
1. 创建一个临时表，有R和W两个字段，且没有索引。
2. 从words表中，按主键顺序取出所有的word值，对每一行计算出一个rand值，分别存入临时表的R和W字段中，此时扫描行数是10000行。
3. 在临时表上按照字段R排序
4. 使用rowid排序，因此需要的值是字段R和位置信息，分别存入sort_buffer中。此时对临时表全表扫描，扫描行数变成了20000行。
5. 在sort_buffer中根据R的值进行排序
6. 排序完成后，取出前三个结果的位置信息，会表到临时表中取出word值。此时总扫描行数为20000+3

- MySQL的表用什么方法来定位一行数据
    - 如果没有主键，InnoDB会自己生成一个长度为6字节的rowid来作为主键。

#### 磁盘临时表
`tmp_table_size`限制了内存临时表的大小，默认是16M，如果超过了这个值，那么就会转成磁盘临时表。当使用临时磁盘表时，对应的是一个没有显示索引的InnoDB表的排序过程。
将`tmp_table_size`设置为1024，把`sort_buffer_size`设置成32768，把`max_length_for_sort_data`设置成16。
因为word字段长度为64大于`max_length_for_sort_data`,因此MySQL使用rowid排序。
R字段为8字节，rowid为6字节，此时sort_buffer需要8*10000+6*10000=140000大于sort_buffer_size。此时不使用临时文件也就是归并排序算法。而是采用了优先队列排序算法。
R
#### 队列优先算法
1. 对于10000个准备排序的(R，rowid)，先取前三行，构成一个堆
2. 取下一行，跟当前堆最大的R比较，如果小于R，就从堆中去掉较大的R，换成新的
3. 重复直到10000个比较完成。

#### 随机排序方法
