set aotucommit  = 0
set session transaction isolation level read uncommited;
造成的原因
脏读--读未提交造成
一个事务读到另一个事务未提交的数据

不可重复读--读已提交
一个数据被其他人多次更新期间，被另一个事务在事务期间多次读取，读取的数据不同

幻读--可重复读


间隙锁：锁范围，如（1， 3）
临键锁：锁[1, 3]
意向锁：实际操作时，

主从复制
binlog-->主从复制
master操作

并行复制MTS
规则：
1.更新同一行的多个事务，必须分发到同一个worker中执行。
2.同一事务不能被拆开，必须要放到同一个worker中执行。

库粒度下：
worker必须要添加一个标识：db

表粒度下：标识：库名.表名

行粒度下：库名.表名.唯一值

新的模式GTID：全局事务id
GTID：包含服务器的唯一标识+递增的事务id

5.7 采用什么样的并行复制策略
binlog日志如何写的？
二阶段提交--保证crash-safe（也就是服务器宕机时，也能恢复数据）

组提交：将多个事务redo log的刷盘动作合并，减少磁盘书序写。就像购买把多个东西放进购物车一起付款
那么怎么判断将哪些事务放在同一组？
给个时间窗口，在时间窗口内提交

双1操作

show variable like '%parallel%'
5.6 只支持以库级别
5.7  
8.0x




读写分离
分库分表

主从复制的延迟问题

优化：
监控SQL
连接优化
数据库设计优化
sql语句优化
设置mysql参数
分布式集群如何设计