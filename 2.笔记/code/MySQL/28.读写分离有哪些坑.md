#### 读写分离的两种架构
- 客户端直连
    - 优点：查询性能稍好，整体架构简单，排查问题更方便
    - 缺点：客户端需要了解后端部署细节，主备切换时，需要调整数据库连接信息。

- 带`proxy`的架构
    - 优点：对客户端比较友好，不需要关心后端细节、连接维护、后端信息维护等。
    - 缺点：对后端维护团队的要求会更高，`proxy`也需要高可用架构，因此较复杂。

过期读：客户端执行一个更新事务后马上发起查询，如果查询的是从库，可能读到刚刚的事务更新之前的状态。
过期读的主要解决方案：
1. 强制走主库
2. sleep方案
3. 判断主备无延迟方案
4. 配合semi-sync方案
5. 等主库位点方案
6. 等GTID方案

#### 强制走主库方案
将请求做分类：
1. 对于必须要拿到最新结果的请求，强制走主库
2. 对于可以读到旧数据的请求，走从库。

无法应对所有查询都不能是过期读的需求，此时都走了主库。

#### Sleep方案
主库更新后，读从库之前先sleep一下。具体方案即执行一条类似`select sleep(1)`
该方案基于主备延迟在1s以内。

#### 判断主备无延迟方案
`show slave status`结果中的`seconds_behind_master`参数的值，可以用来衡量主备延迟时间的长短。
1. 每次从库执行查询请求前，先判断`seconds_behind_master`是否等于0
2. 对比位点确保主备无延迟
    ![[截屏2021-10-24 下午3.52.44.png]]
    - `Master_Log_File`和`Read_Master_Log_Pos`，表示定位是读到的主库的最新位点
    - `Relay_Master_Log_File`和`Exec_Master_Log_Pos`表示备库执行的最新位点

如果此时对应的值完全相同，表示接收到的日志已经同步完成。
3. 对比GTID结合确保主备无延迟
- `Auto_Position=1`，表示主备关系使用了GTID协议。
- `Retrieved_Gtid_Set`,是备库收到的所有日志的GTID集合
- `Executed_Gtid_Set`，是备库所有已经执行完成的GTID集合

如果两个集合相同，也表示备库收到的日志都已经同步完成。
同样是不准确的。因为主库执行完成写入binlog，反馈给客户端，binlog可能存在这样一种情况
![[截屏2021-10-24 下午4.20.00.png]]
此时主库执行完成了三个事务trx1、trx2、trx3,其中：
1. trx1和trx2已经传到了从库，并且已经执行完成了
2. trx3在主库执行完成，并且已经恢复给了客户端，但是还没有传到从库中

#### 配合semi-sync
半同步复制做了这样的设计：
1. 事务提交的时候，主库把binlog发给从库
2. 从库收到binlog以后，发送给主库一个ack，表示收到了
3. 主库收到这个ack以后，才给客户端返回事务完成的确认。

此时可以保证所有给客户端发送过确认的事务，都确保了备库已经收到了这个日志。
该方案只适合一主一备。
缺点：
1. 一主多从，在某些从库查询请求会存在过期读的现象
2. 在持续延迟的情况下，可能出现过度等待的问题

#### 等主库位点方案
```
select master_pos_wait(file, pos[, timeout]);
```
1. 在从库执行
2. 参数file和pos指的是主库上的文件名和位置
3. timeout可选，设置为正整数N表示这个函数最多等待N秒

该命令正常返回的结果是一个正整数M，表示从命令开始执行，到应用完file和pos表示的binlog位置，执行了多少事务。
还会返回一些其他结果：
1. 如果执行期间，备库同步线程发生异常，则返回NULL
2. 如果等待超过N秒，则返回-1
3. 如果刚开始执行的时候，发现已经执行过这个位置了，则返回0

先执行trx1，再执行查询请求逻辑，保证查到正确的数据：
1. trx1事务更新完成后，马上执行`show master status`得到当前主库执行到的File和Position
2. 选定一个从库执行查询语句
3. 在从库上执行`select master_pos_wait(File, Position, 1)`
4. 如果返回结果>=0，则在这个从库执行查询语句,否则就到主库执行查询语句。

#### GTID方案
```
select wait_for_executed_gtid_set(gtid_set, 1);
```
1. 等待，直到这个库执行的事务中包含传入的gtid_set，返回0
2. 超时返回1

等GTID的执行流程：
1. trx1事务更新完成后，从返回包直接获取这个事务的GTID，记为gtid1
2. 选定一个从库执行查询语句
3. 执行上述语句
4. 如果返回值是0，则在这个从库执行查询语句，否则到主库执行