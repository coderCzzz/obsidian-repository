表结构
```
 CREATE TABLE `t` (
`id` int(11) NOT NULL,
`c` int(11) DEFAULT NULL,
`d` int(11) DEFAULT NULL,
PRIMARY KEY (`id`),
KEY `c` (`c`)
) ENGINE=InnoDB; 

insert into t values(0,0,0),(5,5,5),
(10,10,10),(15,15,15),(20,20,20),(25,25,25);
```
执行下列语句
```
begin
select * from t where d=5 for update
```
当命中d=5时，有该数据，因此在select语句执行完之后,id=5这一行会加一个写锁，由于两阶段锁协议，这个写锁会在执行commit语句的时候释放。
由于字段d上没有索引，因此这条查询语句会做全表扫描，那么被扫描到的，但是不满足条件的5行记录，会被加锁吗？

#### 幻读是什么
![[幻读-假设只在id=5加锁.png]]
假设三次查询分别是Q1、Q2、Q3，当读到id=1这一行的现象，被称为幻读。也就是说，幻读指的是一个事务在前后两次查询同一个范围的时候，后一个查询看到了前一次查询没有看到的行。
**注意**：
- 在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此幻读在当前读下才会出现。
- sessionB的修改结果，被sessionA之后的语句用当前读看到，不能称为幻读。幻读仅专指新插入的行。

#### 幻读导致的问题
- 语义被破坏
    - 原本语义是要把d=5的行锁住，不准别的事务进行读写操作，实际上没有保证。原来语句只保证了给id=5的行加锁。如果把其他行的d改为5，再改对应行的数据是可以修改的。
 - 数据一致性问题
     ![[幻读-假设只在id=5这一行加行锁-数据一致性问题.png]]
     1. 经过T1时刻，id=5这一行变成(5,5,100)
     2. 经过T2时刻，id=0这一行变成(0,5,5)
     3. 经过T4时刻，表里面多了一行(1,5,5)
     此时`binlog`的内容：
     1. T2时刻，sessionB事务提交，写入了两条语句
     2. T4时刻，sessionC事务提交，写入了两条语句
     3. T6时刻，sessionA事务提交，写入了`update t set d=100 where d=5`这条语句。
     即：
     ```
     update t set d=5 where id=0
     upadte t set c=5 where id=0
     insert into t value(1,1,5)
     update t set c=5 where id=1
     update t set d=100 where d=5
     ```
     此时运行结果变化变成了(0,0,5)、(1,5,100)和(5,5,100)
     此时可以看出id=0和id=1发生了数据不一致。
     **为什么会导致数据不一致**
     因为只单独给id=5这一行加了锁。
    解决：给扫描过的所有行加锁，以及不存在的行加锁。
    
    #### 如何解决幻读
    
产生幻读的原因：行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的间隙，因此引入了间隙锁(Gap Lock)
间隙锁：锁住两个值之间的间隙
![[幻读-间隙锁.png]]
此时有7个间隙,当你执行`select * from t where d=5 for updat`时不只给数据库里已有的6个记录加上了行锁，还同时加了7个间隙锁。这样就保证了无法再插入新的记录。也就是说，在一行行扫描时，不仅给行加了锁，还给行两边的间隙也加上了锁。
- 跟行锁冲突的是另一个行锁，但是跟间隙锁冲突的是往间隙中插入一个记录的这个操作。看下面的例子
![[幻读-间隙锁之间不互锁.png]]
因此表t里没有c=7这个记录，因此sessionA加的是间隙锁(5,10)。而sessionB也是在这个间隙加的间隙锁，他们的意思一致：不允许在这个间隙插入值，因此不冲突，sessionB不会被堵住。
- 临键锁
    - 间隙锁和行锁合称临键锁next-key lock，每个临键锁都是前开后闭区间
- 间隙锁和临键锁带来的问题
    - 业务逻辑：任意锁住一行，如果这一行不存在就插入，如果存在这一行就更新它的数据。可能会造成死锁。
    ![[幻读-间隙锁导致的死锁.png]]
    sessionA加间隙锁(5,10),sessionB同样加间隙锁(5,10),sessionB尝试插入一行，被sessionA的间隙锁堵住，同理sessionA被sessionB的间隙锁锁住。
    `InnoDB`的死锁检测马上发现死锁，让sessionA的insert语句报错返回。
   - 间隙锁只有在可重复读隔离级别才会生效。可能将隔离级别设为读已提交，同时为了解决可能出现的数据和日志不一致问题，需要将binlog格式设置为row。

