#### 全字段排序的过程
1. 初始化`sort_buffer`，确定查询的字段
2. 从索引中找到第一个满足条件的主键id
3. 回表取出查询的字段，存入`sort_buffer`
4. 从索引中取下一个满足记录的主键id
5. 重复3、4直到不满足查询条件
6. 对`sort_buffer`中的数据按照排序字段做快速排序（这一步可以在内存中完成，也可能使用外部排序，取决于所需的内存和参数`sort_buffer_size`，如果排序的数据库小于这个参数，排序就在内存中完成。如果数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序)

可以通过查看`OPTIMIZER_TRACE`的结果来确认，从`number_of_tmp_files`中查看是否使用了临时文件。
- number_of_tmp_files
**MySQL使用外部排序时使用归并排序算法。将需要排序的数据分成12份，每一份单独排序后存在这些临时文件中。然后把这12个有序文件再合并成一个有序的大文件**
**如果这个参数的值为0，表示排序可以直接在内存中完成，否则在临时文件中排序。sort_buffer_size越小，需要分成的份数越多，number_of_tmp_files的值就越大**
- examined_rows表示参与排序的行数
- sort_mode 排序模式

#### rowid排序--另一种排序方式
上述排序方法将数据放入`sort_buffer`，因此如果字段较大，就会导致使用临时文件，排序的性能会很差。
`SET max_length_for_sort_data = 16;`该参数是MySQL中专门控制用于排序的行数据的长度的一个参数，如果单行的长度超过这个值，MySQL就认为单行太大，要换一个算法。
新的算法放入`sort_buffer`的字段只有要排序的列和主键id。此时整个流程就变成了如下所示的样子--rowid排序：
1. 初始化`sort_buffer`，确定要需要放入的字段和主键id
2. 从索引中找到第一个满足条件的主键id
3. 回表，取排序字段和主键id放入`sort_buffer`
4. 从索引去下一个满足条件的主键id重复3直到不满足条件
5. 对`sort_buffer`中的数据按照排序字段排序
6. 遍历排序结果，并按照主键回表取出需要查询的字段。

#### 全字段排序 VS rowid排序
- 如果MySQL担心排序内存太小，影响排序效率，会采用rowid排序算法，这样排序过程可以排序更多行，但是需要再回表取数据
- 如果MySQL认为内存足够大，则会优先选择全字段排序，把需要的字段都放到`sort_buffer`，这样排序后就会直接从内存里面返回查询结果，不需要回表。
- 对于InnoDB来说，rowid排序会要求回表造成磁盘读，因此不会被优先选择。
- 实际上不是所有的order by语句都需要排序操作的。因为原来的数据都是无序的，因此需要生成临时表，并且在临时表上做排序操作。
- 如果可以保证排序字段在索引上，就不用使用临时表了。
