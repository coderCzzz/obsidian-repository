不同的存储引擎，支持不同的锁机制。
## 不同存储引擎对锁的支持
- `MyISAM`与`MEMORY`:表级锁
- `BDB` ：页面锁
- `InnoDB`：既支持行锁，也支持表锁，默认情况下是行锁。

## 不同锁的特性
- 表级锁：开销小，加锁快；不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发度最低。
- 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高。
- 页面锁：介于上述两者之间。

## 全局锁
- 对整个数据库实例加锁。
- 加全局锁方法`Flush tables with read lock`,可以让整个库处于只读状态。
- 使用场景：做全库逻辑备份。
- 另一种备份方法：使用mysqldump使用参数`-single-transaction`，导数据之前会启动一个事务，拿到一致性视图。 
    - 缺点：需要引擎支持可重复读隔离级别。如`MyISAM`就不支持。

## MyISAM表锁
1. 查询表级锁争用情况
`show status like 'table%'`
如果table_locks_waited的值比较高，则说明存在比较严重的表级别锁争用情况

2. MySQL表级锁的锁模式
- 表共享读锁：当一个session对某个表加了读锁之后，该session只能访问加锁的这个表，而且只能进行读操作；其他session可以对这个表进行读操作，但是进行写操作会被阻塞，需要等待锁的释放。
- 表独占写锁：当一个session对某个表加了写锁之后，该session只能访问这个加锁的表，可以进行读写操作，其他session对这个表的读写操作都会被阻塞，需要等待锁的释放。

MyISAM表的读操作和写操作之间、以及写操作之间是串行的。

3. 如何加表锁
- 加读锁：`lock table tbl_name read`
- 加写锁：`lock table tbl_name write`
- 释放锁：`unlock tables`

- **MyISAM在执行查询语句前，会自动给涉及的表加读锁；执行更新操作前，会自动给涉及的表加写锁。这个过程不需要用户干预。**
- **当加锁时，不仅需要一次锁定用到的所有表，而且同一个表在SQL语句出现多少次，就要通过与SQL语句中相同的别名锁定多少次**


4. 并发插入
**concurrent_insert**：专门控制并发插入的行为
- 0：不允许并发插入
- 1：如果表中没有被删除的，则允许一个进程读表的同时，另一个进程从表尾进行插入。
- 2：无论表中有没有空洞，都允许在表尾并发插入记录。

只需要`lock table tbl_name local read`,在满足上述并发插入条件时，用户就可以在表尾插入记录，但是更新操作会被阻塞。

5. MyISAM锁调度
- 当写进程和读进程同时请求同一个表的写锁和读锁时，写进程优先获得锁。即使读进程先到锁等待队列，写请求后到，写锁也会插入到读锁请求之前。
- 使用以下手段可以调节`MyISAM`的调度行为
    - 指定启动参数`low-priority-updates`，使`MyISAM`引擎默认给与读请求优先权利
    - 执行`SET low-priority-updates =1`，使该连接发出的更新请求优先级降低
    - 指定`INSERT`、`UPDATE`、`DELETE`语句的`LOW_PRIORITY`属性，降低该语句的优先级。
    - 给系统参数`max_write_lock_count`设置一个合适的值，当一个表的读锁达到这个值后，MySQL就暂时将写请求的优先级降低，给读进程一定获得锁的机会。

## 表锁中的MDL（元数据锁）
- 不需要显式使用，在访问一个表时，会自动加上。
- 当对一个表进行增删改查时，加MDL读锁。
- 对表结构做变更操作时，加MDL写锁。
- 读锁之间不互斥，也就是可以有多个线程同时对一个表增删改查。
- 读写锁之间，写锁之间互斥。

## 两阶段锁
- 行锁在需要的时候加上
- 事务结束了，才会释放对应的锁。

## 死锁与死锁检测
![[截屏2021-10-28 上午7.58.42.png]]
因为两阶段锁，两个线程互相等待对方释放自己想要的锁，导致死锁。
- 出现死锁后
    - 直接进入等待，直到超时。超时时间由参数`innodb_lock_wait_timeout`设置。默认50s。有点久了。
    - 发起死锁检测。发现死锁后，主动回滚死锁链条中的一个事务。将参数`innodb_deadlock_detect`设置为on。一般采用这种方式。


## InnoDB锁问题
1. 查询InnoDB行锁争用情况
`show status like 'innodb_row_lock%'`
如果`InnoDB_row_lock_waits`和`InnoDB_row_lock_time_avg`的值比较高，说明锁争用比较严重，这时可以通过设置`InnoDB Monitors`来进一步观察发生锁冲突的表、数据行，并分析锁争用的原因
- 打开监视器
    - `CREATE TABLE innodb_monitor(a INT)ENGINE=INNODB`
    - `show innodb status\G`
- 停止监视器
    - `DROP TABLE innodb_monitor`
打开监视器，默认情况下每15s会向日志中记录监控的内容，如果长时间打开会导致.err文件变得非常巨大，所以用户在确认问题原因之后，要记得删除监控表以关闭监视器，或者通过使用`--console`选项来启动服务器以关闭写日志文件。

2. InnoDB行锁及加锁方式
- 行锁有两种：共享锁S和排他锁X。
- 为了实现行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（都是表锁）：意向共享锁和意向排他锁；一个事务在给数据行加锁之前必须先去的对应表对应的意向锁。
- 意向锁是InnoDB自动加的，不需用户干预。
- 对于`UPDATE`、`DELETE`、`INSERT`语句，InnoDB会自动给涉及的数据加排他锁；对于普通的SELECT语句，InnoDB不会加任何锁；
- 事务可以通过以下语句显示给记录集加共享锁或排他锁。
    - `set autocommit=0`
    - 共享锁（S）`SELECT * FROM tbl_name WHERE ...LOCK IN SHARE MODE`
    - 排他锁(X):`SELECT * FROM tbl_name WHERE FOR UPDATE`
    - 释放锁：`unlock tables`隐含提交事务

- 当一个事务获得一个表的共享锁时，其他事务可以查询该表的记录，也可以对该记录加共享锁。
- 当一个事务对表进行更新操作时，若存在另一个事务也在该表加了共享锁，则需要等待锁的释放。
- 

3. InnoDB行锁实现方式

**通过给索引上的索引项加锁实现**，因此
- 只有通过索引条件检索数据，InnoDB才使用行锁，否则将使用表锁
- 访问不同行的记录，但是如果使用相同的索引键，会出现锁冲突。
- 当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁
- 即便在条件中使用了索引字段，但是否使用索引来检索数据是否MySQL通过判断不同执行计划的代价来决定的。如果MySQL认为全表扫描的效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁而不是行锁。

4. 间隙锁
当使用范围条件检索数据的时候，对于键值在条件范围内但不存在的记录，InnoDB也会进行加锁，这个锁就叫间隙锁。
使用间隙锁的目的，一方面是为了防止幻读，另一方面是为了满足恢复和复制的需要。
这种加锁机制会阻塞符合条件范围内键值的并发插入，造成严重的锁等待，所以应该尽量避免使用范围条件来检索数据。
除了通过范围条件加锁使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，也会使用间隙锁。

5. 临键锁

6. 恢复和复制的需要对InnoDB锁机制的影响

7. InnoDB使用表锁的情况及注意事项

8. 死锁


## 详解间隙锁
1. 什么是间隙锁
间隙：采用范围条件查询数据时，InnoDB会对这个范围的数据进行加锁。如有id为1、3、5、7的4条数据，我们查找1-7范围的数据，那么1-7都会被加上锁，2、4、6在范围内但是不存在这些数据记录，就被称为间隙。加的锁就被称为间隙锁。
间隙锁的范围是( ]。

2. 间隙锁的危害
范围查找时，会把整个范围的数据全部锁定住，即使这个范围内不存在的一些数据，也会被锁定住。比如如果你锁定了1-7，此时有个事务要插入一条id为2的，就会一直等待。

3. 什么时候会产生间隙锁

- 查找某一范围内的语句
- 对于指定查询某一条记录的加锁语句，如果该记录不存在，会产生行锁和间隙锁，如果记录存在，则会只产生行锁。

4 . 间隙锁为什么可以解决幻读的问题
