## 索引的数据结构
### 索引的数据结构可选的有数组、哈希、树，而MySQL是用B+树作为索引的。那么为什么要使用B+树而不用其他的数据结构呢？
1. 使用数组的话可以实现随机查找，查找较快，但是涉及到插入删除操作的话性能表现较差。
2. 使用哈希可以实现随机查找，时间复杂度为O(1),删除插入也还行，但是哈希不支持范围查找。
3. 先看B树的优点，B树的多叉搜索平衡树。相较于普通的平衡搜索二叉树，降低了树的深度，因此可以降低查找的深度搜索次数。又拥有平衡搜索树排序的优点。

### B树与B+树的区别，为什么要选择B+树
1. B树与B+树的区别在于，B树将key和data都放在结点，而B+树的非叶子节点只放置key，而data全部放置在叶子节点。
2. MySQL每次读取的最小单位为页，一页为16k的数据。
![[mysql数据结构选择的副本.jpg]]
3. 因此如图所示，在磁盘块大小固定的情况小，每个节点里多放data就会导致对应的key变少，进而导致深度变大，增大查询时磁盘的io次数，进而影响查询性能。

![[mysql索引系统.jpg]]
4. 由上图可以看到，当非叶子节点只保存key时，磁盘块就能保存更多key进而降低深度，并且可以尽可能多的增多不同的区间

## 索引分类
- 主键索引：不可为null
- 唯一键索引：可以为null
- 普通索引
- 联合索引
- 全文索引

## (非)聚簇索引、回表、索引覆盖、前缀索引、最左匹配原则、索引下推
- 聚簇索引：在建立表时，mysql会自动根据主键建立一个索引，该索引的key为主键，data为对应行所有数据。如果没设定主键，则会使用唯一键；如果没有唯一键，则会生成一个6字节的row_id当做索引。
- 非聚簇索引：如果创建索引的是其他字段，则对应的data是主键，称为非聚簇索引。
- 回表：根据非聚簇索引查询其他字段时，先根据索引查找到对应的主键id，再根据主键id到主键的索引树上查找对应的字段信息，这种过程称为回表。
- 索引覆盖：当你使用非聚簇索引查询时，不需要回表就能得到你要的数据，称为索引覆盖。
- 前缀索引：根据前面的知识可以知道，当索引字段较小的时候，一个磁盘块可以尽可能多的承载key，因此当要建立的索引字段较长时，我们可以使用字段的前几个作为索引。
- 最左匹配索引：如果我们要根据多个字段查询，此时建立多个索引也会浪费空间，造成性能上的损耗，因此可以建立联合索引。联合索引的匹配规则是最左匹配原则，从左往右一次匹配对应的索引。
如在name 和age建立联合索引，则
```
select * from student where name = 'zhangsan' and age =11 会匹配name和age，且调整位置依然会走，因此优化器会自己优化调整位置，而
select * from student where name ='zhangsan' and card = '23332' and age= 11 只会根据name查询，因为中间card破坏了最左匹配原则
```
- 索引下推：在我们查询时，如果组合索引中包含我们要过滤的条件，如上面第二个，虽然不走组合索引，但是会根据age进一步过滤，这称为索引下推。


## 索引优化
- 基于上面的知识我们可以想到的索引优化策略

1. 让建立索引的字段尽可能小
2. '%ss%'会导致索引失效
3. select * 会导致必须回表
4. 在非分布式场景下，尽量使用自增主键，这样可以尽量减少页分裂与页合并。
5. 在更新的时候，选择普通索引而不是主键索引[[各种buffer#change buffer]]

## 为什么有时候会选错索引
- 写SQLS时自己没有指定索引，使用哪个索引是由MySQL自己决定的，因此有时MySQL会自己选择错索引，导致一个本来可以执行很快的语句变的很慢。
### 一个栗子

```
CREATE TABLE `t` (
    `id` int(11) NOT NULL,
    `a` int(11) DEFAULT NULL,
    `b` int(11) DEFAULT NULL,
    PRIMARY KEY (`id`),
    KEY `a` (`a`),
    KEY `b` (`b`)
) ENGINE=InnoDB；
```
插入数据后执行查询语句`select * from t where a between 10000 and 20000`，此时显然使用索引a。
如果接下来我们把数据全删了，再插入10w条语句，继续执行上述查询，就不会使用索引a而是全表扫描--***这种情况对应了平时不断删除历史数据和新增历史数据的场景*

### 优化器的逻辑
**优化器会根据扫描行数、是否使用临时表、是否排序等因素进行综合判断**

#### 扫描行数是怎么判断的
根据统计信息估算记录数。
统计信息：也就是**索引的区分度**。一个索引上不同的值越多，这个索引的区分度就越好。一个索引上不同的值的个数，称为**基数**
**如何得到索引的基数？**
采样统计：InnoDB默认选择N个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了基数。
因为数据表持续更新，因此，当变更的数据行数超过1/M的时候，会自动触发重新做一次索引统计。
两种存储索引统计的方式，可以通过`innodb_starts_persistent`的值来选择：
on：表示统计信息会持久化存储。此时N
默认是20，M默认是10。
off：统计信息只存储在内存中，此时N默认是8，M默认是16。
**除此之外，还有一些其他因素会影响判断的扫描行数**。如：如果使用普通索引，需要回表，则优化器判断的扫描行数是：普通索引扫描的行数+回表时需要扫描的行数

#### 解决
如果发现explain的结果中预估的rows值跟实际情况差很多，因此导致了优化器选择错了索引，可以使用`analyze table table_name`重新统计索引信息。

### 另一个栗子
执行语句`select * from t where (a between 1 and 1000) and (b between 5000 and 10000) order by b limit 1`
如果执行这句查询，如果使用a索引，则需要扫描索引a的前1000行，再到主键索引上查出每一行，如果使用b索引，则需要扫描50000行，因此，好像是应该使用a索引，但实际上却是使用b索引
实际上是优化器认为使用b索引就不需要排序了

### 索引选择异常和处理
- 采用`force index`强行选择一个索引。（可能会面临变更及时性的问题
- 考虑修改语句，引导mysql使用我们期望的索引
    - 如可以把上述语句改为`order by b,a limit 1`
- 某些场景下，可以新建一个更合适的索引，来提供给优化器做选择或删掉误用的索引。

### 什么情况下不会用到索引
- 索引选择性太差
- `<>`、`not in`无法使用索引
- `is null`会使用索引,`is not null`不会使用索引
- 不符合最左匹配原则
- 对索引列进行计算或使用函数

### 删除冗余索引
- `pt_duplicate_key_checker`是`percona-toolkit`工具包中的实用组件
	- 可以帮助你检测表中重复的索引或者主键
	- 使用`/usr/local/bin/pt_duplicate_key_checker --host=ip地址 --user='用户名' --password='数据库密码' --database='数据库名字' --tables='对应表'`

### 实用索引SQL语句
- 索引使用状况统计
```
SELECT
	object_type,object_schema,object_name,index_name,
	count_read,count_fetch,count_insert,
	count_update,count_delete
FROM
	performance_schema.table_io_waits_summary_by_index_usage
ORDER BY
	sum_timer_wait desc;
```

### 减少表与索引碎片
- analyze table表名 重新计算统计信息
- optimize table 表名  优化表空间，释放表空间，会锁表
