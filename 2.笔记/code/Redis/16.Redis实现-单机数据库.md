# 数据库
## 服务器保存数据库
```
struct redisServer{
	// 数组，保存服务器中的所有数据库
	redisDb *db:
	// 服务器的数据库数量,决定创建多少个数据库，由服务器配置的database参数决定，默认16:
	int dbnum;
}
```

## 服务器切换数据库
```
typedef struct redisClient{
	// 记录客户端当前正在使用的数据库
	redisDb *db；
}redisClient
```

## 数据库保存键值对
每个服务器由结构`redisDb`表示，结构中的`dict`字典保存了数据库中所有的键值对，这个字典称为键空间。
```
typedef struct redisDb{
	// 数据库键空间，保存数据库中的所有键值对
	dict *dict
}redisDb;
```

## 对数据库的增删改查
- 实际上是对数据库的键空间进行增删改查（可以理解为对HashMap增删改查）
- 对键空间读写时，还会伴随其他操作，如更新键的LRU、删除过期键、

## 数据期保存键过期与删除过期键
- 保存过期时间
`redisDb`结构的`expires`字典保存了数据库中所有键的过期时间，该字典称为过期字典。`key`是对应的数据库键对象，值是对应的过期时间。

### 过期键的删除策略
- 定时删除：设置定期时间时，设置定时器，到指定时间执行删除操作
	- 内存友好，可以保证尽快被删除
	- 对CPU时间最不友好，要删除的较多时，会占用部分CPU时间。
	- 定时器用到的时间事件，使用无序链表，大量事件时，查找一个事件的并不高效。
- 惰性删除：放任键过期不管，但是每次从键空间获取键时，都检查取得的键是否过期
	- CPU最友好
	- 内存最不友好。
- 定期删除：每隔一段时间，检查过期键
	- 上面两种方式的折中。限制删除操作的时长和效率来减少删除操作对CPU时间的影响。
	- 定期删除减少内存浪费
- `Redis`服务器实际使用的是惰性删除和定期删除两种策略配合。

### AOF、RDB与复制功能对过期键的处理
- RDB：
	- 生成RDB文件时，会对键进行检查，已经过期的键不会被保存到RDB文件中
	- 载入RDB文件时：主服务器会对文件中保存的键进行检查，未过期被载入，过期的被忽略；从服务器不会检查，都会被载入。但是因为主服务器进行数据同步会清空从服务器，所以也不会有什么影响
- AOF
	- 写入：过期键没有被惰性删除或定期删除，则AOF不会受影响。被惰性删除或定期删除时，会向AOF追加一条`DEL`命令，显示记录该键被删除。
	- 重写：重写时，会对键进行检查，已过期的不会被保存到重写后的AOF文件。
- 复制
	- 从服务器的删除由主服务器控制--保持主从一致
	- 主服务器删除过期键，则会向所有从服务器发送一个`DEL`命令
	- 从服务器执行读命令，即使碰到过期键也不会删除，而是像处理未过期的键一样处理
	- 从服务器只有接收到`DEL`命令，才会删除过期键

# RDB持久化
## 保存与载入RDB文件方法
### 创建RDB文件
- SAVE命令阻塞Redis服务器进程，直到RDB文件创建完成为止，服务器都不能处理命令请求
- BGSAVE派生出子进行，由子进程负责创建RDB文件，服务器进程继续处理命令请求。
	- 执行BGSAVE期间，客户端再次发送的`SAVE BGSAVE BGREWRITEAOF`都会被拒绝。
- 通过不同方式调用`rdbSave()`实现
```
def SAVE():
	# 创建RDB文件
	rdbSave()
def BGSAVE():
	# 创建子进程
	pid = fork()
	if pid ==0
		# 子进程负责创建RDB文件
		rdbSave()
		# 完成后向父进程发送信号
		signal_parent()
	else pid > 0
		# 父进程继续处理命令请求，并通过轮训等待子进程信号
		handle_request_and_wait()_singal()
	else
		# 处理出错情况
		handle_fork_error()
```
### 载入RDB文件
- 启动时检测有RDB文件存在，就自动载入
- 开启了APF持久化，则优先使用AOF文件还原数据库状态
- 只有在AOF功能关闭时，才使用RDB文件还原数据库
- 载入时，服务器一直处于阻塞状态，直到载入工作完成。

## 自动保存实现原理
### 自动间隔保存
- 通过设置`save time changes`让服务器每隔一段时间自动执行一次`BGSAVE`
```
struct redisServer{
	# saveparam数组，每个saveparam结构体记录time和changes
	struct saveparam *saveparams;
	
	# 距离上次SAVE或BGSAVE服务器对数据库进行了多少次修改
	long dirty；
	
	# 上一次执行保存时间
	time_t lastsave;
}
```
### 检查保存条件是否满足
- `serverCron()`函数默认每隔100毫秒执行一次，其中一项工作检查save选项的保存条件是否已经满足。
```
def serverCron():    
	# ...
	#遍历所有保存条件￼     
	for saveparam in server.saveparams:￼           #计算距离上次执行保存操作有多少秒
	   save_interval = unixtime_now()-server.lastsave
	   #如果数据库状态的修改次数超过条件所设置的次数
	   #并且距离上次保存的时间超过条件所设置的时间      
	   #那么执行保存操作
	   if server.dirty ＞= saveparam.changes and save_interval ＞saveparam.seconds     
	   BGSAVE()
```
## RDB文件组成部分
![[截屏2022-01-28 下午9.33.06.png]]
- REDIS：5字节常量字符`REDIS`，快速检查载入文件是否为`RDB`文件。
- db_version:4字节，标识`RDB`文件版本号。
- database：包含多个数据库以及数据库中的键值对数据
- EOF：常量，标识RDB文件正文内容结束
- check_sum:校验和，检验`RDB`文件是否出错或损坏

#### database部分
![[截屏2022-01-28 下午9.37.44.png]]
![[截屏2022-01-28 下午9.38.00.png]]
- SELECTDB:1字节，**标识下一个要读的是数据库号码**
- db_number:数据库号码，读到这部分，就要开始切换数据库了
- key_value_pairs:保存了数据库中所有的键值对
	- ![[截屏2022-01-28 下午9.40.39.png]]
	- ![[截屏2022-01-28 下午9.41.17.png]]
## 实际RDB文件分析与解读
- `od`命令：用给定的格式转存并打印输入文件
	- `-c`以`ASCII`码，`-x`以16进制
- `Redis`自带`RDB`文件检查工具`redis-check-dump`，网上也有很多工具

# AOF持久化
- RDB保存数据库的键值对，而AOF是保存服务器所执行的写命令。

## AOF持久化实现
### 命令追加
- 服务器在执行完一个写命令后，会以协议格式将谢明丽追加到服务器状态的`aof_buf`缓冲区末尾
```
struct redisServer{
	// AOF缓冲区
	sds aof_buf；
}
```
### 文件写入与文件同步
- Redis服务器进程是一个事件循环：文件事件负责接收客户端请求以及回复；时间事件负责执行定时任务；最后一步考虑是否将`aof_buf`的内容写入和保存到`AOF`文件
```
def eventLoop():   
	while True:       
		#处理文件事件，接收命令请求以及发送命令回复   #处理命令请求时可能会有新内容被追加到 aof_buf缓冲区中       
		processFileEvents()
		#处理时间事件    
		processTimeEvents()       
		#考虑是否要将 aof_buf中的内容写入和保存到 AOF文件里面     
		flushAppendOnlyFile()
```
- `flushAppendOnlyFile`的行为由服务器配置中的`appendfsync`的值决定
	- always：将缓冲区的所有内容写入aof并同步
	- everysec：将所有内容写入aof，如果上次同步的时间距现在超过1s，则再次对aof文件进行同步
	- no：所有内容写入aof文件，且不同步，何时同步由操作系统决定
- 这里的同步是指操作系统将文件从操作系统的内存缓冲区刷到磁盘，写入是指将数据暂时保存在操作系统缓冲区。

## AOF文件载入与数据还原
- 执行步骤
	1. 创建一个不带网络连接的伪客户端
	2. 从AOF文件分析并读取一条写命令
	3. 使用伪客户端执行写命令
	4. 重复执行2、3，直到AOF中所有写命令被处理完毕为止

## AOF重写
### AOF重写实现
- AOF文件重写不使用原来的AOF文件，而是通过读取服务器当前的数据库状态来实现的。
- 在实际中，为了避免在执行命令时造成客户端输入缓冲区溢出，重写程序在处理列表、哈希表、集合、有序集合这四种可能会带有多个元素的键时，会先检查键所包含的元素数量，如果元素的数量超过了redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD常量的值，那么重写程序将使用多条命令来记录键的值，而不单单使用一条命令

### AOF后台重写
- AOF通过子进程进行重写，使用开始重写时的副本数据
- 为了解决重写后，又有新数据进来的问题，使用AOF重写缓冲区
	- 当Redis服务器执行完一个写命令之后，会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。
- 当AOF重写完成后，发给父进程信号，父进程调用信号处理函数：
	- 将aof重写缓冲区的所有内容写入到新AOF文件
	- 对新AOF进行改名并替换旧AOF文件


# 事件
- Redis服务器是一个事件驱动程序。

## 文件事件
- 服务器与客户端的通信会产生响应的文件事件（如发送数据、接收数据、建立连接等都是事件）
- `Redis`基于`Reactor`模式开发了事件处理器:文件事件处理器`file event handler`
	- 使用IO多路复用同时监听多个套接字，根据套接字执行的任务关联不同的事件处理器
	- 当被监听的套件字准备好连接应答、读取、写入、关闭等操作时，与操作对应的文件事件就会产生，此时调用对应的事件处理器进行处理

### 文件事件处理器的组成
![[截屏2022-01-28 下午11.04.07.png]]



## 时间事件
- 需要在指定时间点进行的操作就是时间事件

### 实现
- 将所有的时间事件放在一个无序链表，每当时间事件执行器运行时，就遍历整个链表，查找所有已到达的时间事件，并调用相应的时间处理器

## 事件的调度与执行
![[截屏2022-01-28 下午11.43.05.png]]


# 客户端
- 使用IO多路复用技术实现文件事件处理器。服务器使用单线程单进程的方式处理命令请求，并与多个客户端进行网络通信。
## 客户端属性
## 客户端的创建与关闭

# 服务器
## 命令请求的执行过程
## serverCron函数
## 初始化服务器