## 概述
### 什么是垃圾
1. 垃圾指在运行程序中没有被任何指针指向的对象。

### 为什么需要GC
1. 不进行垃圾回收，内存迟早会被消耗完
2. 除了释放没用的内存，垃圾回收也可以清除内存里的记录碎片，将整理出的内存分配给新的对象

### 应该关系哪些区域的回收
1. 垃圾收集器对年轻代、老年代、甚至是全栈和方法区的回收
2. 主要是堆
3. 从次数上来说：频繁收集新生代、较少收集老年代、基本不收集元空间或永久代
4. 程序计数器、虚拟机栈、本地方法栈不用多考虑回收的问题，因为方法结束或线程结束，内存自然跟着回收。
5. 方法区一般不回收，但是具体还是看垃圾回收器的实现，如JDK11的ZGC收集器就不支持方法区的类型卸载。


## 垃圾回收相关算法
### 如何确定哪些对象需要回收
- 怎么判断是否是一个死亡对象：当一个对象已经不再被任何的存活对象继续引用时
- [[#引用的分类]]

#### 引用计数算法
##### 思路
1. 对每个对象保存一个整型的引用计数器属性，表示对象被引用的情况
2. 对一个对象A，任何对象引用了A，引用计数器+1，引用失效，引用计数器-1.当=0时表示对象A不可能再被使用，可进行回收。

##### 优缺点：
- 优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性
- 缺点：
	- 需要单独字段存储计数器，增加了存储空间的开销
	- 每次赋值，增加了时间开销
	- 最主要的，无法处理循环引用的情况。因此java中并没有使用这种算法。


#### 可达性分析算法
##### 实现思路
- `GCRoots`根集合：一组必须活跃的引用
- 基本思路：
	1. 以`GCRoots`根集合为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达
	2. 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接，搜索所走过的路径称为引用链
	3. 如果对象没有任何引用链相连，表示不可达，可标记为垃圾对象

##### GC Roots可以是哪些元素
1. 在虚拟机栈(栈帧中的本地变量表)中引用的对象，譬如各个线程被调用的方法堆栈中使用到的 参数、局部变量、临时变量等。
2. 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。 
3. 在方法区中常量引用的对象，譬如字符串常量池(String Table)里的引用。
4. 在本地方法栈中JNI(即通常所说的Native方法)引用的对象。 ·
5. Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象(比如NullPointExcepiton、OutOfMemoryError)等，还有系统类加载器。 ·
6. 所有被同步锁(synchronized关键字)持有的对象。 ·
7. 反映Java虚拟机内部情况的JM XBean、JVM TI中注册的回调、本地代码缓存等。


- 除了上述这些固定的集合外，根据用户所选用的垃圾回收器以及当前回收区域的不同，还可以临时加入其他对象，共同构成完成的`GC Roots`。因为如果是局部收集，则可能该局部可能被其他区域所引用。


##### vs引用计数算法
1. 相对于引用计数算法，可达性算法不仅同样具备实现简单和执行高效的特点，更重要的是该算法可以有效的解决在引用计数算法中循环引用的问题，防止内存泄露的发生。
2. java就是选择了这种可达性分析算法，基于这种算法的垃圾收集叫追踪性垃圾收集。

##### 对象的finalization机制
###### finalize()方法机制
1. java语言提供了对象终止机制来允许开发人员提供对象销毁前的自定义处理逻辑。
2. 垃圾回收对象之前，总会调用这个对象`finalize()`方法
3. `finalize()`方法允许在子类中被重写，用于对象被回收时进行资源释放。
###### 注意
1. 永远不要主动调用某个对象的`finalize()`方法，应该交给立即回收机制调用,因为：
	1. `finalize()`时可能导致对象复活
	2. `finalize（）`执行时间是没有保障的，完全由GC线程决定，极端的情况，不发生GC则永远没有执行机会。
	3. 可能会严重影响GC性能，如`finalize()`是个死循环
2. `finalize()`对应了`finalize`线程，即使主动调用该方法，也不会因此直接回收。

###### 生存还是死亡
- 由于`finalize()`，虚拟机中的对象可能存在三种状态：
	- 可触及的：从根节点开始，可以到达这个对象
	- 可复活的：对象的所有引用都被释放，但是对象可能在`finalize()`中复活
	- 不可触及的：对象的`finalize()`被调用，且没有复活，则进入不可触及状态
- 只有对象在不可触及时才可以被回收。

###### 具体过程
- 判定一个对象是否可回收，至少要经过两次标记过程
	1. 对象到`GC Roots`没有引用链，进行第一次标记
	2. 进行筛选，判断次对象是否有必要执行`finalize()`方法
		1. 如果没有重写，或者`finaliez()`已经被调用，判定为不可触及
		2. 如果重写了且未执行过，则对象被插入到`F-Queue`队列中，一个虚拟机自动创建、低优先级的`Finalizer`线程触发器`finalize()`方法执行。
		3. 稍后GC对`F-Queue`队列中的对象进行第二次标记。如果对象在`finalize()`方法中与引用链中的任何一个对象建立了联系，则在第二次标记时，将其移除即将回收集合。之后，对象再次出现没有引用的情况，由于`finalize()`只执行一次，对象直接变成不可触及的。


### 清除阶段：
#### 标记-清除算法Mark-Sweep
##### 执行过程
- 当堆中内存被耗尽时，停止整个程序(`stop the world`)，然后开始**标记**和**清除**     
	- 标记：收集器从引用根节点开始遍历，标记所有被引用的对象
	- 清除：对堆内存从头到尾线性遍历，发现某个对象的`Header`中没有被标记为可达对象，则将其回收。

##### 缺点
- 效率不高
- 进行GC期间，需要停止整个应用程序，用户体验较差
- 该方法清除出来的空闲内存不是连续的，产生碎片，需要维护一个空闲列表。

##### 清除的定义
- 不是真正的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象加载时，判断垃圾的位置空间是否够。够的话，就存放。


#### 复制算法
##### 核心思想
- 将活着的内存空间分为两块，每次使用其中一块，垃圾回收时，将正在使用的内存中的活着的对象复制到未被使用的内存中，清除之前使用的内存中的所有对象，交换两块内存中
- 新生代即使用了这种算法，将`Eden`区和`S0`区存活对象整体复制到`S1`区
![[截屏2021-11-07 上午10.59.15.png]]

##### 优缺点
- 优点
	- 没有标记和清除过程，实现简单，运行高效
	- 复制过去以后保证内存的连续性，不会出现碎片内存
- 缺点
	- 需要两倍内存空间

##### 应用场景
1. 如果系统中垃圾对象很多，则需要复制的存活对象数量并不会太大，效率很高
2. 老年代大量对象存活，效率很低
3. 新生代效率较高


#### 标记-压缩算法
##### 背景
1. 复制算法针对存活对象少，垃圾对象多的情况效率很高，但是对于老年代效率很低，因此针对老年代需要一个新算法
2. 标记清除算法可以用在老年代，但是效率低，还会产生内存碎片
3. 在标记清除算法的基础上优化，就有了标记压缩算法。

##### 执行过程
1. 第一阶段还是从根节点标记所有被引用对象
2. 第二阶段将所有的存活对象压缩到内存的一端，按顺序排放，之后清除边界外的所有的空间

##### 优缺点
- 优点
	- 消除了标记清除算法内存区域碎片化的缺点
	- 消除了复制算法需要内存双倍的代价
- 缺点
	- 效率上低于复制算法
	- 移动过程中，如果对象被其他对象引用，需要调整引用地址。
	- 移动过程中，需要全程暂停用户应用程序。

### 分代收集算法
#### 为什么要分代收集
1. 不同对象的生命周期不同，根据不同的生命周期对象采用不同的收集方式，以便提高回收效率

### 增量收集算法
#### 背景
- 上述垃圾回收中，应用程序有可能处于STW状态，如果时间过程，验证影响用户体验

#### 基本思想
1. 垃圾收集线程每次只收集一小片区域的内存空间，接着切换到应用程序线程，依次反复，直到垃圾收集完成。
2. 基础是标记-清除和复制算法。

### 分区算法
1. 堆空间越大，一次GC需要的时间就越长，为了控制GC停顿时间，将一大块内存分割为多个小块，根据目标停顿时间，每次合理回收若干个小区域。
2. 分区算法将整个堆空间划分成连续的不同小区域，每个小区间都独立使用，独立回收。


## HotSpot算法实现细节
### 如何查找枚举根节点
> 方法区很大，如果高效的检查哪些引用可以放进GC Roots集合中？可达性分析需要在一致性快照中进行，如何确保分析过程中引用关系不变化？
- 使用一个叫`OopMap`的数据结构，在类加载阶段和编译阶段就记录下引用情况，保存到这个数据结构。

### 安全点
> 运行过程中会可能导致OopMap内容变化，是否有必要每一条指令都记录一下
- 没必要。在特定的点，才需要去检查OopMap是否变化，因此GC的时刻也不是随时都可以进行的。
- 在特定的位置，也就是安全点才开始停顿下来GC。
- 安全点的选取以“能否让程序长时间执行”为标准，一般是方法调用、循环跳转、异常跳转等。

> 如何在GC发生时让所有线程到安全点再停下来
- 抢占式
	- 先把所有线程都中断，如果发现有线程中断的地方不在安全点，就恢复线程，让它跑到安全点。--几乎没有采用这种方式的虚拟机
- 主动式
	- 需要中断的时候，设置一个标志，线程去轮询，发现标志位真就自己中断挂起
		- 标志点与安全点重合，再加上创建对象需要分配内存的地方。

### 安全区域
- 安全区域：一段代码片段，引用关系不会发生变化。对这个区域的任意地方开始GC都是安全的。
- 代码执行到安全区域时，标识自己进入。在这段时间内如果JVM要GC，就不需要管线程的状态了。当线程要离开安全区域时，检查系统是否已完成根节点枚举或GC，完成则线程继续执行，未完成需要等待可以离开安全区的通知。

### 记忆集与卡表
#### 记忆集
> 针对跨代引用的情况，记录老年代中是否有引用到新生代。将含有跨代引用的保存在记录
- 保存的精度
	- 字节精度
	- 对象精度： 精确到对象，对象的某个字段含跨代指针
	- 卡精度： 精确到内存块，内存块中某个对象含跨代引用

#### 卡表
- 卡表可以看成是记忆集在卡精度范围内的实现
-  `HotSpot`使用数组作为具体实现
```
CARD_TABLE [this address >> 9] = 0;
```
- 数组索引为内存起始地址，每块内存称为内存页，可以看出内存页大小默认为512kb，当内存页中含有跨代引用，该页称为脏页，将数组元素置为1否则为0。

### 写屏障
> 当跨代引用发生变化时，如何维护卡表
- 如果是解释执行，虚拟机是可以干预字节码的。但是如果是编译执行，虚拟机无法干预即时执行的机器码
- 在引用复制前加一个AOP切面，这个切面就是写屏障。
- 在引用后通过后置通知，也就是写后屏障去更新对应卡表状态。

### 三色标记
> 为什么标记-清除期间需要在保障一致性的快照中分析
- 在可达性分析时，将引用分为三色
	- 白色：未被访问过的对象。显然如果对象如果在分析结束后仍然是白色，则为不可达
	- 灰色：被访问过，但是这个对象还有至少一个引用未被访问
	- 黑色：被访问到，且该对象的所有引用都已被访问。代表存活的对象。 如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对 象不可能直接(不经过灰色对象)指向某个白色对象。
- 在标记线程和用户线程并发执行时，可能会出现对象消失的情况，当且仅当下列情况同时发生时出现：
	- 插入了一条或多条黑色指向白色的新引用
	- 删除了全部灰色到白色的直接或间接引用。
- 两种解决方案
	- 增量更新（破坏第一个条件）：当插入新的黑色指向白色的引用时，保存这条记录，扫描完成后，再以黑色引用为根节点，重新扫描一次。--CMS
	- 原始快照（破坏第二个条件）：当灰色对象要删除一条白色引用时，保存要删除的引用，等扫描完成后，再以灰色为根节点，重新扫描--G1
- 因为上述插入和删除都会改变引用关系，可能会改变卡表，因此都是这些操作都是通过写屏障实现的。
## 面试题
### 蚂蚁金服
1. 有哪几种垃圾回收器，各自的优缺点，重点讲一下CMS和G1
2. JVM GC算法有哪些？目前的JDK版本采用什么回收算法
3. G1回收器讲下回收过程GC是什么？为什么要GC
4. GC的两种判定方法？CMS收集器和G1收集器的特点

## 引用的分类
### 什么是引用
- 一块内存，存储着另一个内存的起始地址，这个内存就是引用。

### 分类
- 根据垃圾回收的必要性，分为4种
	- 强引用 ：只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象
	- 软引用 ：一些有用但非必要存在的对象。系统在发生内存溢出之前，才会将这些对象考虑回收
	- 弱引用：只存活到下一次垃圾回收之前。无论内存是否足够，都会被回收掉。
	- 虚引用：虚引用的唯一目的只是在某个对象被收集器回收时收到一个系统通知。