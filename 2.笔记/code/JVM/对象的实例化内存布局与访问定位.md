## 对象创建的方式
1. new
2. Class的newInstance方法
3. Constryctor的newInstance(Xxxx):反射的方法，可以调用空参或无参的构造器
4. 使用clone()：不调用任何构造器，要求当前的类实现`Cloneable`接口的clone方法
5. 使用序列化：从文件中或网络中获取一个对象二进制流
6. 第三方库Objenesis

## 对象创建步骤
### 从字节码角度
1. 判断对象对应的类是否加载、链接、初始化
	1. 虚拟机遇到new指令，先去检查这个指令的参数能否在元空间的常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始化
	2. 如果该类没有加载，在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为key查找对用的.class，没找到抛出异常，找到进行类加载，并生成对应的Class对象
2. 为对象分配内存
	1. 首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅引用变量空间即可
	2. 如果内存规整：采用指针碰撞分配内存
		1. 如果内存规整，采用指针碰撞法为对象分配内存
		2. 即所有用过的内存在一边，空闲的内存在一边，中间放一个指针作为分界点的指示器，分配内存仅仅是把指针往空闲内存那边挪动一段与对象大小相等的距离。
		3. 如果垃圾回收器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。
		4. 标记压缩（整理）算法会整理内存碎片，堆内存一存对象，另一边为空闲区域
	3. 如果内存不规整
		- 如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。
		- 意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”
		- 选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定
		- 标记清除算法清理过后的堆内存，就会存在很多内存碎片。
3. 处理并发问题
	1.  采用CAS+失败重试保证更新的原子性
	2.  每个线程预先分配TLAB - 通过设置 -XX:+UseTLAB参数来设置（区域加锁机制）
	3.  在Eden区给每个线程分配一块区域
4. 初始化分配到的空间
	- 所有属性设置默认值，保证对象实例字段在不赋值可以直接使用
	-   给对象属性赋值的顺序：
		1.  属性的默认值初始化
		2.  显示初始化/代码块初始化（并列关系，谁先谁后看代码编写的顺序）
		3.  构造器初始化
5. 设置对象的对象头
	- 将对象的所属类（即类的元数据信息）、对象的hashcode和对象的GC信息、锁信息等数据存储在对象的对象头中。该过程取决于JVM实现。
6. 执行init方法进行初始化
	1. 在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量
	2. 因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行init方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。

## 对象内现布局

## 对象的访问定位
![[截屏2021-11-04 下午2.54.47.png]]
### 对象的两种访问方式
#### 句柄访问
![[截屏2021-11-04 下午2.56.15.png]]
- 缺点
	- 在堆空间中开辟可一块空间作为句柄池，句柄池本身也会占用空间；通过两次指针访问才会访问到堆中的对象，效率低。
- 优点
	- `reference`中存储稳定句柄地址，对象被移动时只会改变句柄中实例数据指针，`reference`不会被修改
#### 直接访问(HotSpot采用)
![[截屏2021-11-04 下午2.58.52.png]]
- 优点
	- 直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中也有类型指针，指向方法区中的对象类型数据
	- 对象被移动需要修改`reference`的值