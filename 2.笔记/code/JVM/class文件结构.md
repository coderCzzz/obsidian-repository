## 概述
- Class文件以8个字节为基础单位，各个数据项目严格按照**顺序紧凑**排列在文件之中，中间没有任何分割符。
- 如果存储的数据项超过8个字节时，会按照高位在前的方式分割存储。
- 文件中只有无符号数和表两种结构
	- 无符号数以`u1 u2 u4 u8`分别代表1、2、4、8个字节。
	- 表是多个无符号数或其他表的复合数据结构，以`_info_结尾。`

![[截屏2021-11-15 上午11.02.14.png]]
## 通过例子学习class文件组成
- 栗子代码
```
package org.fenixsoft.clazz;

public class TestClass {

	public int m;
	
	public int inc() {
		return m+1;
	}
}
```

#### 栗子对应字节码
![[截屏2021-11-15 下午2.49.17.png]]
### 魔数与版本号
- class文件的前4个字节`CAFE BABE`标识这个文件是否是能被虚拟机接受的Class文件
- 紧接着魔数的后4个字节，前两位是次版本号，后两位是主版本号

### 常量池
- 紧接着版本号后的2个字节是常量池容量计数值`constant_pool_count`,计数从1开始而不是0（0代表不引用任何一个常量池内容）。上述常量池计数为0x0016，即十进制的22。
- 常量池中主要存放两大类常量:字面量和符号引用。
	- 字面量主要是文本字符串、被声明为final的常量值等
	- 符号引用主要为
		- 被模块导出或开放的包
		- 类和接口的全限定名
		- 字段的名称和描述符
		- 方法的名称和描述符
		- 方法句柄和方法类型
		- 动态调用和动态常量
- 因为Class文件不会保存各个方法、字段最终的内存地址，因此需要虚拟机在运行期将符号引用转化为真正的内存地址
- 常量池中每一项常量都是一个表，一共有20种类型,每种表有不同的表结构

#### 常量池的项目类型
![[截屏2021-11-15 下午2.40.14.png]]
- 每一项常量都是一个表，表的第一位是u1类型的标志位tag。
- 上述常量池计数器后紧接着一位是0x07，对应常量池类型为`CONSTANT_Class_info`
- `CONSTANT_Class_info`的结构
![[截屏2021-11-15 下午2.53.20.png]]
- `name_index`是一个2字节的索引值，指向常量池中`CONSTANT_Utf8_info`类型常量，此常量代表了这个类或接口的全限定名。栗子中该值为0x0002，也就是指向常量池中的第二项常量。
- 接着第二项的tag就是0x0001，查表可知确实是`CONSTANT_Utf8_info`类型
- `CONSTANT_Utf8_info`结构
![[截屏2021-11-15 下午2.59.07.png]]
- `length`表示这个字符串的长度是多少字节，后面跟着长度为`length`字节的连续数据
	- 该连续数据使用`UTF-8`缩略编码表示的字符串
	- 缩略编码：1-127的ASCII码用一个字节表示，`\u0080`(128)到`\u07ff`(2047)使用两个字节，再后面的用三个字节表示
- 栗子中`length`为001D即29字节，往后29字节翻译后刚好为`org/fenixsoft/TestClass`
- 因为`lenght`2字节，最大值为65535，也就是说java程序中方法、字段的最长长度为65535。
- 使用`javap -verbose 类名`帮助查看字节码常量池表
![[截屏2021-11-15 下午3.10.19.png]]
### 访问标志
- 常量池结束后，紧接着2个字节表示访问标志
- 用于识别一些类或接口的访问信息：如类还是接口；是否被定义为public、是否被定义为abstract。
- 具体标志类型目前只有9种。注意，2个字节有16bit可以用，因此其他没有用到的位全部置0
![[截屏2021-11-15 下午3.13.56.png]]
### 类索引、父类索引与接口索引
- 类索引`this_class`、父类索引`super_class`都是u2类型的数据，而接口索引集合是一组u2类型的数据的集合，由这三项数据来确定该类型的继承关系。
- 类索引确定类的全限定名，父类索引确定父类的全限定名。各自指向一个类型为`CONSTANT_Class_info`的类描述常量，通过常量中的索引值找到`CONSTANT_Utf8_info`常量中的全限定名字符串。
- 接口索引集合的第一个u2类型的值为接口计数器。
![[截屏2021-11-15 下午3.35.24.png]]
查看字节码，这三个值分别是0x0001、0x0003、0x0000，对比javap计算出的常量池，可以找出类名与父类名
![[截屏2021-11-15 下午3.36.31.png]]
### 字段表集合
- 字段`field_info`用于描述接口或类中声明的变量。
![[截屏2021-11-15 下午3.39.27.png]]
- 字段修饰符2个字节，与类的`access_flag`类似
![[截屏2021-11-15 下午3.40.12.png]]
- `name_index`和`descriptor_index`对常量池的引用，表示字段的简单名称以及字段和方法的描述符
	- 全限定符很好了理解，简单名称就是不带类型和参数修饰的，如`m`和`inc`
	- 方法和字段的描述符：用来描述字段的数据类型、方法的参数列表和返回值
- 看栗子
![[截屏2021-11-15 下午3.44.16.png]]
### 方法表集合
- 方法表结构
![[截屏2021-11-15 下午3.46.30.png]]
- 方法访问标志
![[截屏2021-11-15 下午3.47.14.png]]
- 方法的定义可以根据访问标志、`name_index`、`descriptor_index`得到，方法中的代码经过编译，存放在方法属性表中一个叫`Code`的属性里面。
- 栗子
![[截屏2021-11-15 下午3.51.01.png]]
- `Methods_count`计数器容量为2表示有2个方法：实例构造器`<init>`和我们写的`inc()`；第一个方法的访问标志为0x0001表示public，名称索引值为0x0007对照常量池查的为`<init>`，描述符索引值为0x0008，对应常量为`()V`，属性表计数器值为1表示此方法的属性表集合有1项数据，属性名称索引为0x0009，对应常量为Code。

### 属性表集合
- Class文件、字段表、方法表都可以携带自己的属性表集合，描述某些场景转有的信息。
- 要求较宽松，不需要各个属性表具有严格顺序。

#### 虚拟机预定义的属性
![[截屏2021-11-15 下午3.57.21.png]]
...未完
- 对于每一个属性，它的名称都要从常量池引用的常量表示![[截屏2021-11-15 下午3.59.12.png]]

#### Code属性
- java方法体内的代码经过编译器处理之后，最终变为字节码指令存储在Code属性内。

![[截屏2021-11-15 下午6.30.51.png]]
- `max_stack`代表了操作数栈深度的最大值。
- `max_locals`代表局部变量表所需的存储空间。
- `code`和`code_length`用来存储编译后的字节码指令和字节码指令长度。

#### Exception属性
- 列举出方法中可能抛出的受查异常。

....
