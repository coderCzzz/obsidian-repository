### 虚拟机栈出现背景
- 跨平台设计，使用基于栈的指令集而不是基于寄存器的指令集。

### 虚拟机栈
#### 内存中的栈与堆
1. 栈存储局部变量、函数参数、上下文环境等
2. 堆用来分配给程序员去申请的内存空间。

#### 虚拟机栈基本内容
- java虚拟机栈：每个线程在创建时都会创建一个虚拟机栈，内部保存一个个栈帧，对应一次次方法调用。
- 生命周期与线程一致。
- 作用：保存方法的局部变量（8种基本数据类型、对象的引用地址）、部分结果，参与方法的调用与返回。

#### 虚拟机栈异常
- 如果是固定大小的java虚拟机栈，当线程请求分配的栈容量超过允许的最大容量时，会抛出`StackoverflowError`异常
- 如果容量可以动态拓展，当尝试拓展无法申请到足够的内存，或者创建的时候，没有足够的内存去创建对应的线程，则会抛出`OutofMemoryError`异常

#### 设置栈内存大小
-Xss

### 栈的存储单位
#### 栈中存储
1. 每个线程都有自己的栈，栈中的数据都是以**栈帧**的格式存在
2. 在这个线程上正在执行的每个方法都对应一个栈帧
3. 栈帧是一个内存区块，是一个数据集，维系者方法执行过程中的各种数据信息。
#### 栈运行原理
1. 一个时间点，只有一个活动的栈帧，对应有当前栈帧、当前方法、定义当前方法的当前类等概念。
2. 执行引擎运行的所有字节码指令只针对当前栈帧进行操作
3. 如果在方法中调用了其他方法，对应的新栈帧就会被创建，放在栈的顶端。
![[截屏2021-11-01 下午10.21.30.png]]
1. 不同线程中的栈帧不允许相互引用。
2. 一个方法调用其他方法，返回时，当前栈帧会传回给此方法的执行结果给前一个栈帧，接着虚拟机丢弃当前栈帧，使得下一个栈帧称为当前栈帧。
3. 有2种返回函数的方法
    1. 正常返回`return`指令
    2. 抛出异常

#### 栈帧的内部结构
![[截屏2021-11-01 下午10.24.11.png]]
每个栈帧中存储着：
- 局部变量表
- 操作数栈或表达式栈
- 动态链接
- 方法返回地址
- 一些附件信息
- 某些地方将动态链接、方法返回地址、附件信息合称帧数据区

##### 局部变量表
1. 作用：保存方法参数和定义在方法体内的局部变量。包含基本数据类型、对象引用、`returnAddress`类型。
2. 数据结构：数字数组
3. 大小：编译器确定，保存在方法的`Code`属性的`maximum local variables`数据项中，方法运行期间不会改变其大小。
4. 数据安全：安全。建立在线程的栈上，是线程的私有数据。
5. 生命周期：只在当前方法调用中有效，方法调用结束后，随着方法栈帧的销毁随之销毁。

###### 局部变量表与字节码指令
- 使用`jclasslib`来看局部变量表
![[截屏2021-11-02 下午3.48.00.png]]
   1. 局部变量的作用域范围即(start PC, start PC+length)
   2. `start PC`指字节码行号
   3. index实际上就是下面说的slot的索引
- 使用`javap -v`可以将字节码解析成能看的懂的形式
- 解析后的样子如下，可以看到`locals=3`即局部变量表的大小
![[截屏2021-11-02 下午3.41.49.png]]
- 使用`jclasslib`来看其他部分字节码
	- 具体的字节码
	 ![[截屏2021-11-02 下午3.43.15.png]]
	- 方法异常表
	![[截屏2021-11-02 下午3.44.06.png]]
	- Misc
	![[截屏2021-11-02 下午3.44.28.png]]
	- 行号表 ：java代码的行号与字节码指令航哈哈的对应关系
	![[截屏2021-11-02 下午3.45.33.png]]

###### 局部变量表的最基本存储单元-Slot
1. 存放各种编译期可知的数据
2. 局部变量表中，32位以内的数据类型只占用一个`Slot`(包括`returnAddress`类型)；64位类型(`long和double`)占用两个`slot`
	- `byte short char boolean`在存储前被转换成int
3. JVM会为局部变量表的每一个slot分配一个访问索引，通过这个索引可成功访问到局部变量表中指定的局部变量值
4. 当一个实例方法被调用时，它的方法参数和局部变量将会按顺序被复制到局部变量表中的每一个`slot`上
5. 如果当前帧是由构造方法或者实例方法创建，那么该对象引用this将会存放在index为0的slot处，其他的参数按照顺序继续排列。

###### slot的重复利用
- 栈帧中的局部变量表中的槽位是可以重用的。如果一个局部变量过了其作用域，那么在其作用域之后申明新的变量就可能复用过期局部变量的槽位。

###### 静态变量与局部变量的对比
1. 静态变量有两次复制机会：第一次在“准备阶段”，执行系统初始化，对静态变量设置零值。第二次在“初始化阶段”,赋予程序员在代码中定义的初始值。
2. 与静态变量不同，局部变量不存在系统初始化的过程，使用前，必须人为的初始化。

###### 注意
- 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。

##### 操作数栈
- 能够完成复制、交换、求和等操作的栈
- 作用：保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。
- 栈深度：每个操作数栈都有一个明确的栈深度用于存储数据，最大深度在编译期间就定义好了，保存在方法的`Code`属性中，为`maxstack`的值
- 元素所占深度：32位占一个栈单元，64位占两个栈单元。

###### 栈顶缓存技术
- 因为基于栈的指令集，因此完成一项操作就可能需要多次访问内存，包括内存的读写（操作数保存在内存），因此将栈顶元素全部缓存在物理cpu的寄存器中，来降低对内存的读写次数。

##### 动态链接
- 每一个栈帧在运行时常量池中都有一个包含该栈帧所属方法信息的值。每一个栈帧内部都保存了一个对该值的引用。
- 该引用的目的就是为了支持当前方法的代码能够实现动态链接。比如`invokedynamic`指令。
- java源代码被编译成字节码文件时，所有的变量和方法引用都作为符号引用保存在class文件的常量池中。
- 当一个方法调用另一个方法时，就是通过常量池中的符号引用表示的。动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。

> 例子解释
```
public class DynamicLinkingTest {

    int num = 10;

    public void methodA(){
        System.out.println("methodA()....");
    }

    public void methodB(){
        System.out.println("methodB()....");

        methodA();

        num++;
    }

}
```
摘录下一些重要的字节码
- 常量池  `#1`这种就是符号引用
```
Constant pool: 
#1 = Methodref #9.#23 // java/lang/Object."<init>":()V 
#2 = Fieldref #8.#24 // com/atguigu/java1/DynamicLinkingTest.num:I 
#3 = Fieldref #25.#26 // java/lang/System.out:Ljava/io/PrintStream; 
#4 = String #27 // methodA().... 
#5 = Methodref #28.#29 // java/io/PrintStream.println:(Ljava/lang/String;)V 
#6 = String #30 // methodB().... 
#7 = Methodref #8.#31 // com/atguigu/java1/DynamicLinkingTest.methodA:()V 
#8 = Class #32 // com/atguigu/java1/DynamicLinkingTest 
#9 = Class #33 // java/lang/Object #10 = Utf8 num #11 = Utf8 I
...
```
- 上例中的方法调用
![[截屏2021-11-02 下午4.47.13.png]]
我们通过#7找到需要调用的`methodA()`方法，并进行调用。
- 为什么要用常量池
	- 因为在不同的方法，都可能调用常量或方法，所以只需要存储一份即可，然后记录其引用，节省空间。
	- 常量池作用：提供符号和常量，便于指令的识别。

**所以动态链接就是指将方法作为符号保存在常量池，当方法A需要调用的方法B时候，将指针直接指向常量池中方法B的符号引用即可**

#### 方法调用
在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关

##### 静态链接与动态链接
- 静态链接：当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译器确定，且运行期保持不变，这种情况下将调用方法的符号引用转为直接引用的过程称为静态链接。
- 动态链接：被调用的方法无法在编译器就确定下来，即只能在程序运行期将调用的方法的符号引用转换为直接引用，称为动态链接。
##### 早期绑定和晚期绑定
> 静态链接与动态链接针对的是方法。早起绑定和晚期绑定范围更广。早期绑定涵盖了静态链接，晚期绑定涵盖了动态链接
- 绑定指一个字段、方法或者类在符号引用被替换为直接引用的过程。只发生一次。
- 早期绑定
	- 被调用的目标方法在编译器可知，且运行期保持不变，即可将方法与所属类型进行绑定
- 晚期绑定
	- 被调用的方法在编译器无法确定，只能给在程序运行期根据实际的类型绑定相关的方法
字节码中：
- invokevirtual 体现为晚期绑定
- invokeinterface 也体现为晚期绑定
- invokespecial 体现为早期绑定

##### 多态与绑定
- java具备早期绑定和晚期绑定两种方式
- java任何一个方法都具备虚函数的特征。如果不希望某个方法拥有虚函数，则可以使用关键字`final`来标记。

###### 虚方法与非虚方法
1. 方法在编译期就确定了具体的调用版本，该版本在运行时不可变，则该方法称为非虚方法
2. 静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法
3. 其他方法称为虚方法。

###### 虚拟机中调用方法的指令
- 普通指令
	1.  invokestatic：调用静态方法，解析阶段确定唯一方法版本
	2.  invokespecial：调用`<init>`方法、私有及父类方法，解析阶段确定唯一方法版本
	3.  invokevirtual：调用所有虚方法
	4.  invokeinterface：调用接口方法
- 动态调用指令

5. invokedynamic：动态解析出需要调用的方法，然后执行

	- 前四条指令固化在虚拟机内部，方法的调用执行不可人为干预。而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。
	-	JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进。
	- 但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。
	- Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。

###### 动态语言与静态语言
1. 区别在于对类型的检查是在编译器还是在运行期，满足前者的就是静态语言，反之就是动态语言。

###### java语言方法重写的本质
- 动态分派过程
	1. 找到操作数栈顶的第一个元素执行的对象的实际类型(第一个是this)，记作C
	2. 到字节码常量池中找符合条件的方法，进行权限校验：通过则返回这个方法的直接引用，查找过程结束；不通过则抛出`java.lang.IllegalAccessError`异常
	3. 没找到就按照继承关系从下往上以此对C的父类进行第2步的搜索和检验
	4. 如果始终没有找到，则抛出`java.lang.AbstractMethodError`异常。

###### 虚方法表
1. 在面向对象编程时，频繁使用动态分派。如果每次动态分派都需要重新在类的方法元数据中搜索合适的目标，效率很低。因此，JVM在类的方法区建立了一个虚方法表。非虚方法不会出现在表中。使用索引来代替查找。
2. 每个类中都有一个虚方法表，表中存放着各个方法的实际入口。
3. 生命周期：在类加载的链接阶段被创建并开始初始化，类的变量初始化准备完成之后，JVM会把该类的虚方法表也初始化完毕。

**例子**
![[截屏2021-11-02 下午6.28.55.png]]
1. 比如son在调用`toString`时，son未重写，父类也未重写，则直接调用object的`toString`。直接在son的虚方法表里指明toString直接执行`Object`类
2. 下次son对象再调用toString就直接去Object，不用先son->father->object。

#### 方法返回地址--一个内存结构
1. 存放调用该方法的pc寄存器的值。方法结束有两种方式：1.正常完成 2.出现异常，非正常退出
2. 无论怎样退出，都返回该方法被调用的位置。**方法正常退出时，调用者的pc寄存器的值作为返回地址，即调用该方法的指令的下一条指令的地址。异常退出时，返回地址通过异常表确定，栈帧一般不会保存这部分信息**
3. 一个方法正常退出时，使用哪一个返回指令根据方法返回值的实际类型而定。

#### 一些附加信息
包括对程序调试提供支持的信息

### 栈相关面试题
- 举例栈溢出的情况
- 调整栈大小，就能保证不出现溢出吗
- 分配的栈内存越大越好吗？不是，一定时间内降低了OOM概率，但是会挤占其他的线程空间，因为整个虚拟机的内存空间是有限的。
- 立即回收是否涉及虚拟机栈？不会
![[截屏2021-11-02 下午6.38.29.png]]