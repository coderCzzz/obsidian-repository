## 栈、堆、方法区的交互关系
### 从线程共享与否的角度来看
![[截屏2021-11-04 上午11.10.56.png]]
### 对象的各种访问位置
1. 类对应的.class信息存放在方法区
2. 类的局部变量存放在java栈的局部变量表
3. 真正的java对象存放在java堆中，对象引用存放在java栈中
4. 对象中有一个指针指向方法区的类数据

![[截屏2021-11-04 上午11.14.11.png]]

## 方法区的理解
### 方法区在哪里
- 虚拟机规范：所有的方法区在逻辑上属于堆的一部分
- HotSpot中方法区别名`Non-Heap`，因此方法区可以看做一块独立于堆的内存空间


### 方法区的基本理解
- 方法区主要存放Class，而堆中主要存放实例化的对象
1. 方法区与堆一样，是各个线程共享的内存区域。多个线程同时加载同一个类时，只要一个能加载，只有一个线程能加载，其他线程需要等待，然后直接使用该类。
2. 方法区在JVM启动时就被创建，实际物理内存可以不连续
3. 方法区的大小可以选择固定或者可拓展
4. 系统定义太多类可能会导致内存区溢出：OOM
5. 关闭JVM会释放方法区的内存。


### HotSpot方法区演进
1. JDK7及以前，将方法区称为永久代。JDK8以后，使用元空间取代永久代。
2. 本质上方法区和永久代不等价。但是对于HotSpot而言是等价的
3. 方法区可以看成是接口，而永久代或元空间是具体的实现。
4. 元空间与永久代的区别：元空间不在虚拟机设置的内充中，而是使用本地内存。


## 设置方法区大小与OOM
### JDK7及以前
1. 通过设置`-XX:Permsize`设置初始分配空间，默认20.75M
2. `-XX:MaxPermsize`设置永久代最大可分配空间
3. 当JVM加载的类信息超过这个值就会报OOM


### JDK8及以后
1. 通过`-XX:MetaspaceSize`和`-XX:MaxMetaspaceSize`指定
2. 默认值依赖于平台，最大值-1，即没有限制
3. 不指定大小时，虚拟机会耗尽所有可用系统内存。
4. 默认值是初始的高水位线，一旦触及，`Full GC`将会被触发并卸载没有的类。然后这个高水位线会被重置。新的高水位线取决于GC后释放了多少元空间。
5. 如果初始高水位先设置过低，调整会频繁发生，`Full GC`多次调用。所以一般设置一个较高值。


### 如何解决OOM
1. 先通过内存映像分析工具对`dump`出来的堆转储快照进行分析，确认内存中的对象是否必要，也就是分析出是内存泄露还是内存溢出
2. 内存泄露就是大量的引用指向某些对象，但这些对象以后不会使用了，但是他们和GC ROOT有关联，导致这些对象不会被回收
3. 如果是内存泄露，可进一步通过工具查看泄露对象到`GC ROOT`的引用链。于是就能找到泄露对象是通过怎样的路径与`GC ROOT`关联并导致垃圾回收器无法自动回收它们。
4. 如果不存在内存泄露，也就是说内存中的对象必须存活，则应检查虚拟机的堆参数，与机器物理内存对比是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长等情况，减少程序运行期的内存消耗。


## 方法区的内部结构
### 方法区存储什么
#### 概念
![[截屏2021-11-04 下午2.10.14.png]]
- 用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。
![[截屏2021-11-04 下午2.11.22.png]]
- 类型信息
	- 该类完整的有效名称
	- 直接父类的完整有效名
	- 该类的修饰符`public、abstract、final`
	- 直接接口的一个有序列表
- 域信息，也就是成员变量
	- 需保存所有域相关信息以及域的声明顺序
	- 域相关信心包括：域名城、域类型、域修饰符（public，private，protected，static，final，volatile，transient的某个子集）
- 方法信息
	- 方法名称
	- 返回类型
	- 参数和数量（按顺序）
	- 方法修饰符
	- 方法字节码、操作数栈、局部变量表及大小
	- 异常表


### non-final类型的类变量
1. 静态变量和类关联在一起，随着类的加载而加载，称为类逻辑上一部分。
2. 类变量被类的所有实例共享
#### 全局常量static final
1. 被声明为final的类变量，每个全局变量在编译时就被分配。


### 运行时常量池
#### 运行时常量池VS常量池
1. 运行时常量池在方法区内部
2. 常量池在字节码文件中，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后存放到方法区的运行时常量池

## 方法区的演进细节
![[截屏2021-11-04 下午2.25.59.png]]
### 永久代为什么要被元空间替代
1. 为永久代设置空间大小很难确定。而元空间使用本地内存，因此大小仅受本地内存限制
2. 对永久代调优很难。

### 字符串常量池
#### 为什么字符串常量池StringTable要调整位置
- JDK7将字符串常量池放到了堆空间。因为永久代的回收效率很低，只有Full GC才会进行永久代的垃圾回收。而Full GC在老年代空间不足、永久代空间不足才会触发。
- 上述原因导致StringTable回收效率不高。而我们的开发中有大量的字符串被创建。


## 方法区的垃圾回收
## 运行时数据区总结
## 直接内存
## 直接内存
## 常见面试题
1.  百度
    -   三面：说一下JVM内存模型吧，有哪些区？分别干什么的？
2.  蚂蚁金服：
    -   Java8的内存分代改进
    -   JVM内存分哪几个区，每个区的作用是什么？
    -   一面：JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？
    -   二面：Eden和survior的比例分配
3.  小米：
    -   jvm内存分区，为什么要有新生代和老年代
4.  字节跳动：
    -   二面：Java的内存分区
    -   二面：讲讲jvm运行时数据库区
    -   什么时候对象会进入老年代？
5.  京东：
    -   JVM的内存结构，Eden和Survivor比例。
    -   JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和survivor。
6.  天猫：
    -   一面：Jvm内存模型以及分区，需要详细到每个区放什么。
    -   一面：JVM的内存模型，Java8做了什么改
7.  拼多多：
    -   JVM内存分哪几个区，每个区的作用是什么？
8.  美团：
    -   java内存分配
    -   jvm的永久代中会发生垃圾回收吗？
    -   一面：jvm内存分区，为什么要有新生代和老年代？
