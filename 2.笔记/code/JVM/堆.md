## 核心概述
### 堆与进程
1. 一个JVM进程只有一个JVM实例，一个JVM实例只有一个运行时数据区，一个运行时数据区只有一个堆和方法区。
2. 一个进程包含多个线程，线程间共享同一个堆空间。
![[截屏2021-11-02 下午9.39.59.png]]
1. 生命周期：JVM启动时创建，其空间大小也随之确定
2. 大小：创建时空间大小被确定，但是可以调节，堆是JVM管理的最大一块内存空间。
3. 虚拟机规范规定，堆可以处于物理上不连续的内存空间，但是逻辑上应该被视为连续。
4. 所有对象实例以及数组在运行时分配在堆上
5. 数组和对象可能永远不会存储在站上，栈帧中保存引用，引用指向对象或者数组在堆中的位置。
6. 方法结束后，堆中的对象不会马上被移除，仅仅在垃圾手机时才被移除
	- 也就是触发了GC的时候，才会进行回收
	- 如果堆中对象马上被回收，那么用户线程就会受到影响
7. 堆是GC执行垃圾回收的重点区域
![[截屏2021-11-02 下午9.46.12.png]]
### 堆内存细分
1. Java7及之前，逻辑上分为三部分：新生区、养老区、永久区
	- `Young Generation Space` 新生区` Young/New`
		- 又被分为`Eden`区和`Survivor`区
	- `Old Generation Space`养老区`Old/Tenure`
	- `Permanent Space`永久区`Perm`
2. Java8之后分为三部分：新生区、养老区、元空间Meta Space
![[截屏2021-11-02 下午9.51.43.png]]
![[截屏2021-11-02 下午9.52.24.png]]
### 设置堆内存大小与OOM
#### 设置堆内存
1. 堆区用于存储java对象实例。堆的大小在JVM启动时已经设定好。
2. 自己可以通过`-Xms`和`-Xmx`设置
	- -Xms表示堆区的起始内存（年轻代+老年代）
	- -Xmx表示堆区最大内存（年轻代+老年代）
3. 一旦堆区中的内存大小超过最大值，将会抛出`OutofMemoryError`异常
4. 通常将-Xmx和-Xms设置一样。可以避免频繁的扩容和释放造成不必要的压力，避免GC后调整堆内存给服务器带来压力
5. 默认情况下
	- 初始内存大小：物理电脑内存大小/64
	- 最大内存大小：物理电脑内存大小/4

### 年轻代与老年代参数
1. 存储在JVM中的java对象可以被划分为两类：
	1. 生命周期较短的顺势对象，这类对象的创建和消亡都非常迅速
	2. 生命周期较长，甚至与JVM一致
2. 配置新生代与老年代在堆结构的占比
	- 默认`-XX:NewRatio=2`，表示新生代占1，老年代占2
3. `HotSpot`中，`Eden`空间和另外两个`survivor`空间的默认占比是8：1：1
4. 可以使用`-XX:SurvivorRatio`调整
5. 几乎所有的java对象都是在`Eden`区被new出来
6. 绝大部分的java对象的销毁都在新生代进行。
7. 可以通过`-Xmn`设置新生代最大内存大小，一般使用默认值

## 图解对象分配过程
### 具体过程
1. new的对象先放`Eden`区，此区有大小限制
2. 当`Eden`区填满时，此时程序又需要创建对象，JVM的垃圾回收器对`Eden`区进行垃圾回收，将`Eden`区的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区
3. 然后将伊甸园中的剩余对象移动到幸存者0区
4. 如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有被回收，就放到幸存者1区
5. 再次触发垃圾回收，此时重复3、4
6. 设置新生区进入养老区的年龄是限制，默认是15.通过设置`-XX:MaxTenuringThreshold=N`
7. 当养老区内存不足时，才进行清理养老区
8. 养老区进行GC后，发现依然无法进行对象的保存，就会产生OOM异常。

### 图解对象分配（一般情况）
1. 创建的对象，放在伊甸园区，当伊甸园区满了之后，触发GC操作，称为YGC。
![[截屏2021-11-02 下午10.26.15.png]]
2. 进行一次垃圾回收之后，红色的对象被回收，绿色的放进S0区，同时将其年龄+1
3. 当伊甸园再次满了之后，触发GC，此时GC会清理伊甸园区和S0区，将存活的对象放到S1区，同时让存活的年龄+1
	- 下一次进行GC时：
		- 这一次S0区为空，成为下一次GC的S1区
		- 这次的S1成为下一次的S0
		- 也就是说S0和S1在互相转换
![[截屏2021-11-02 下午10.31.27.png]]
4. 不断进行对象的生成和垃圾回收，当`Survivor`中的对象年龄达到15时，触发一次`Promotion`晋升的操作，将年轻代的对象晋升到老年代中
![[截屏2021-11-02 下午10.32.49.png]]
垃圾回收：频繁在新生代手机、很少在老年代手机，几乎不再永久区/元空间收集。

### 对象分配特殊情况
1. 来了一个新对象，`Eden`放不下怎么办
直接触发YGC，执行垃圾回收，看看接下来能否放下
1. 对象放到老年代之后，又有两种情况
- 上述执行了YGC，还是放不下，说明是超大对象，只能直接放到老年代
- 如果老年代也放不下，先触发FullGc，看是否能放下，如果还是放不下，报OOM
3. 如果`Eden`满了，发现将对象往幸存区拷贝，如果幸存区放不下，直接晋升老年代
![[截屏2021-11-02 下午10.44.06.png]]

### 常见调优工具
- JDK命令行
- Jconsole
- Visual VM（实时监控，推荐）
- Jpofile（IDEA插件）
- Java Flight Recorder（实时监控）
- GCViewer
- GCEasy

## GC分类
1. JVM调优的一个环节，尽量避免垃圾回收，因为垃圾回收过程中容易出现STW问题，而Major GC和Full GC出现STW的时间，是YGC的10倍以上
2. JVM进行GC时，并非每次都对上面三个内存区域一起回收，大部分时候回收的是指新生代。针对`HotSpot VM`的实现，里面的GC按照回收区域可以分为两大种类型：部分收集`Partial GC`，一种是整堆收集`Full GC`
- 部分收集：不是完整收集整个Java堆的垃圾收集，其中又分为：
	- 新生代收集`Minor GC/YGC`:只是新生代的垃圾收集
	- 老年代收集`Major GC/Old GC`
	- 目前，只有CMS GC有单独收集老年代的行为
	- 很多时候，Major GC和Full GC混淆使用。需要具体分辨
	- 混合收集：收集整个新生代以及部分老年代的垃圾收集。目前只有G1 GC有这种行为。
- 整堆收集Full GC：收集整个java堆和方法区的垃圾

### Young GC
1. 年轻代空间不足，会触发`Minor GC`，这里的年轻代指`Eden`区。`Survivor`满不会主动触发GC,`Eden`满触发GC，会顺带清理s0区的
2. `Minor GC`非常频繁，一般回收速度比较快。
3. `Minor GC`会引发STW，暂停其他用户线程，等垃圾回收结束，用户线程才恢复。

### Major GC
1. 出现Major GC,经常会伴随至少一次`Minor GC`
2. `Major GC`的速度一般会比`Minor GC`慢10倍以上，STW时间更长
3. 如果`Major GC`后内存还不足，报OOM

### Full GC
#### 触发机制
#### 触发Full GC的情况
1. 调用`System.gc()`，系统建议执行FullGC,但是不必然执行
2. 老年代空间不足
3. 方法区空间不足
4. 通过`Minor GC`后进入老年代的平均大小大于老年代的可用内存
5. 由`Eden`区、s0向s1区复制时，对象大于s1可用内存，转到老年代，老年代的可用内存也不够时

**Full GC**是开发或调优中尽量要避免的。这样STW时间会短一些。

### 堆空间分代思想
为什么要分代？
经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。
- 如果没有分代，则所有对象都在一起，GC的时候要找到哪些对象没有，需要对堆全部扫描。
- 把新创建的对象放在一起，垃圾回收时先回收这块的。提高性能。

### 对象内存分配策略
1. 如果对象在`Eden`出生并经过一次`Minor GC`后依然存活，且能被`Survivor`容纳的话，就把它移动到`Survivor`空间中，并将对象年龄设为1
2. 对象在S区每熬过一次JGC，年龄就增加1，当年龄增加到一定程度，就会被晋升到老年代
3. 对象晋升老年代的年龄阈值，可以通过`-XX:MaxTenuringThreshold`设置

#### 针对不同年龄的对象分配原则
1. 优先分配到`Eden`:开发中比较长的字符串或数组，会直接存在老年代。
2. 大对象直接分配到老年代
3. 长期存活的对象分配到老年代
4. 动态对象年龄判断：如果S区中相同年龄的所有对象大小总和大于S区空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代
5. 空间分配担保：`-XX:HandlePromotionFailure`

### TLAB为对象分配内存（保证线程安全）
#### 为什么有TLAB
1. 堆区是线程共享区域，线程线程都可以访问到堆区的共享数据
2. 由于对象实例的创建在JVM中非常频繁，因此在并发环境中从堆区中划分内存空间是线程不安全的
3. 为避免多个线程操作同一地址，需要使用加锁等机制，影响分配速度。

#### 什么是TLAB
TLAB：Thread Local Allocation Buffer
1. 从内存模型而不是垃圾回收的角度，对`Eden`区域进行继续划分，JVM为每个线程分配了一个私有的缓存区域。
2. 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们将这种内存分配方式称为快速分配策略。
![[截屏2021-11-03 下午3.04.39.png]]
1. 每个线程都有一个TLAB空间
2. 当一个线程的TLAB存满时，可以使用公共区域（蓝色）

#### TLAB再说明
1. 尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选
2. 程序中，开发人员可以通过选项`-XX:UseTLAB`设置是否开启TLAB空间
3. 默认情况下，TLAB空间的内存非常小，仅占有整个`Eden`空间的1%。我们可以通过设置`-XX:TLABWasteTargetPercent`设置TLAB空间占用`Eden`空间的百分比
4. 一旦对象再TLAB空间分配内存失败，JVM就会尝试通过使用加锁机制，直接在`Eden`空间中分配内存。
![[截屏2021-11-03 下午3.09.07.png]]
### 堆空间参数设置
```
/**
 * 测试堆空间常用的jvm参数：
 * -XX:+PrintFlagsInitial : 查看所有的参数的默认初始值
 * -XX:+PrintFlagsFinal  ：查看所有的参数的最终值（可能会存在修改，不再是初始值）
 *      具体查看某个参数的指令： jps：查看当前运行中的进程
 *                             jinfo -flag SurvivorRatio 进程id
 *
 * -Xms：初始堆空间内存 （默认为物理内存的1/64）
 * -Xmx：最大堆空间内存（默认为物理内存的1/4）
 * -Xmn：设置新生代的大小。(初始值及最大值)
 * -XX:NewRatio：配置新生代与老年代在堆结构的占比
 * -XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例
 * -XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄
 * -XX:+PrintGCDetails：输出详细的GC处理日志
 * 打印gc简要信息：① -XX:+PrintGC   ② -verbose:gc
 * -XX:HandlePromotionFailure：是否设置空间分配担保
 */
```

#### 空间分配担保
1. 在发生`Minor GC`之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间
	1. 如果大于，则此时JGC是安全的
	2. 如果小于，则虚拟机会查看`-XX:HandlePromotionFailure`设置值是否允许担保失败
		- 如果等于true，则会继续检查老年代最大可用连续空间是否大于历次晋升老年代的对象的平均大小
			- 如果小于，则进行一次Full GC
			- 如果大于，则进行一次JGC，但这次JGC依然是有风险的
		- 等于false，则进行一次Full GC。

**历史版本**
1.  在JDK6 Update 24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。
2.  JDK6 Update 24之后的规则变为**只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC**，否则将进行Full GC。即 HandlePromotionFailure=true

### 堆是分配对象的唯一选择么

**在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：**

1.  随着JIT编译期的发展与**逃逸分析技术**逐渐成熟，**栈上分配、标量替换**优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。
    
2.  在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是**如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配**。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。
    
3.  此外，前面提到的基于OpenJDK深度定制的TaoBao VM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。

#### 逃逸分析
1.  如何将堆上的对象分配到栈，需要使用逃逸分析手段。
2.  这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。
3.  通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。
4.  逃逸分析的基本行为就是分析对象动态作用域：
    -   当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。
    -   当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。

## 小结
1.  年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。
    
2.  老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。
    
3.  当然，也有特殊情况，我们知道普通的对象可能会被分配在TLAB上；
    
4.  如果对象较大，无法分配在 TLAB 上，则JVM会试图直接分配在Eden其他位置上；
    
5.  如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。
    
6.  当GC只发生在年轻代中，回收年轻代对象的行为被称为Minor GC。
    
7.  当GC发生在老年代时则被称为Major GC或者Full GC。
    
8.  一般的，Minor GC的发生频率要比Major GC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。