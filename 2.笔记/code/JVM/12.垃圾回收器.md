## GC分类与性能指标
### 垃圾回收器分类
- 线程数分
	- 串行：同一段时间内只允许有一个CPU用于执行垃圾回收，此时工作线程被暂停，直到垃圾回收工作结束
	- 并行：多条垃圾回收线程并行工作，但是用户线程仍处于等待状态
	- 并发：用户线程与垃圾回收线程同时执行。
- 按工作模式分
	- 并发式：垃圾回收与应用程序线程交替工作
	- 独占式：垃圾回收器STW一旦运行，就停止应用程序中的所有应用线程，直到垃圾回收完全结束
- 按碎片处理方式
	- 压缩式：垃圾回收完成后，对存活对象进行压缩整理，消除碎片，再分配对象使用指针碰撞
	- 非压缩式：不进行压缩整理，对象分配使用空闲列表。

### 评价GC的性能指标
#### 指标
1. 吞吐量：运行用户代码占总运行时间（=程序运行时间+内存垃圾回收时间）的比例
2. 垃圾收集开销：垃圾收集时间与总运行时间的比例
3. 暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间
4. 收集频率：收集操作发生的频率
5. 内存占用：java堆区所占的内存大小
6. 快速：一个对象从诞生到被回收所经历的时间

主要看吞吐量和暂停时间


## 不同垃圾回收器概述
![[截屏2021-11-08 上午9.25.24.png]]
![[截屏2021-11-11 下午10.58.16.png]]
## Serial回收器：串行回收
### 概述
1. 最基本、历史最悠久的垃圾收集器
2. 作为`HotSpot`中`Client`模式下的默认新生代垃圾收集器
3. 采用复制算法、串行回收和STW的方式执行内存回收
4. 除了年轻代之外，还提供老年代垃圾收的`Serial Old`收集器，也采用串行回收和STW机制，但是内存回收算法采用标记-压缩算法。
5. `Serial Old`是`Client`模式下默认的老年代垃圾回收器。在`Server`模式下主要有两个用途：与新生代的`Parallel Scavenge`配合使用；作为老年代CMS收集器的后备垃圾收集方案。

### 优势
1. 限定单核使用下，简单高效
2. 内存资源有限的情况下，额外内存消耗最小
3. 适用于运行客户端模式的虚拟机

## ParNew回收器：并行回收
### 概述
1. `Serial`收集器的多线程版本。除了采用并行回收，没有区别。
2. 很多JVM在`Server`模式下新生代的默认垃圾收集器
3. JDK7以前，只有它和`Serial`能与`CMS`收集器配合。

### 设置ParNew垃圾回收器
- `-XX:+UserParNewGC`手动指定使用`ParNew`收集器。表示年轻代使用并行收集器，不影响老年代。

## Parallel回收器：吞吐量优先
### 概述
1. 采用复制算法、并行回收和STW机制。
2. 为了达到可控制的吞吐量
3. 吞吐量的=用户代码时间/代码时间+垃圾收集时间
4.  Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间 的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数。
5.  Parallel Scavenge收集器还有一个参数-XX:+UseAdaptiveSizePolicy值得我们关注。这是一 个开关参数，当这个参数被激活之后，就不需要人工指定新生代的大小(-Xmn)、Eden与Survivor区 的 比 例 ( - X X : Su r v i v o r R a t i o ) 、 晋 升 老 年 代 对 象 大 小 ( - X X : P r e t e n u r e Si z e T h r e s h o l d ) 等 细 节 参 数 了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。这种调节方式称为垃圾收集的自适应的调节策略(GC Ergonomics)
6. java8中。默认使用该垃圾回收器

### 参数设置
- `-XX:UserParallelGC`：指定年轻代使用
- `-XX:ParallelGCThreads`:设置年轻代并行收集器的线程数，一般最好与CPU数量相等。
	- 默认情况下，CPU小于8个,`ParallelGCThreads`的值等于CPU数量。
	- 大于8个，`ParallelGCThreads`的值等于3+[5*CPU/8]
## CMS回收器：低延迟
1. 采用标记-清除算法，也会STW。
2. 由于回收阶段，用户线程继续执行，因此需要给用户线程留空间，如果内存不够，则会出现`Concurrent Mode Failure`失败，虚拟机启动后备预案：临时启用`Serial old`进行老年代收集。

### 具体过程
1. 初始标记-需STW
	- 仅标记`GC Roots`能直接关联到对象，速度很快。
2. 并发标记-时间最长
	- `GC Roots`遍历整个对象图。此时用户线程不停顿。
3. 重新标记-需STW
	- 修正并发标记阶段用户程序运行导致的变更的标记记录。参考上述三色标记中的增量更新[[垃圾回收概述和相关算法#三色标记]]
4. 并发清除

### 参数设置
- `-XX:CMSInitiatingOccupanyFraction`:设置堆内存使用率阈值，一旦达到该阈值，便开始回收：
- `-XX:CMSFullGCsBeforeCompaction`:设置多少次FullGc后进行对内存进行压缩整理

### 缺点
- 对CPU资源敏感：因为并发执行的垃圾回收线程也消耗CPU资源
- 无法处理浮动垃圾：因为并发清除阶段，用户程序也在运行，可能会生成新的垃圾，这一部分垃圾称为浮动垃圾。
- 使用标记-清除算法，会产生内存碎片。

## G1回收器：区域化分代化
### 思路
- 可预测的停顿时间模型：在一个指定为M毫秒的时间片内，用于垃圾回收的时间不超过N毫秒
- 思路
	- 不像之前的收集器只关注于某一区域的回收，而是关注整个堆空间，组成回收集，标准是哪块内存垃圾多，回收收益最大。
	- 将连续的堆空间划分为大小相同的`Region`，每个`Region`根据需要去扮演`Eden`、`Survivor`甚至是老年代，G1回收器根据区域扮演角色不同采用不同的回收策略。
	-  `Region`中还有一类特殊的`Humongous`区域，专门用来存储大对象。G1认为只要大小超过了一个  R e gi o n 容 量 一 半 的 对 象 即 可 判 定 为 大 对 象 。 每 个 R e gi o n 的 大 小 可 以 通 过 参 数 - X X : G 1 H e a p R e gi o n Si z e 设 定，取值范围为1M B~32M B，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象， 将会被存放在N个连续的`Humongous Region`之中，G1的大多数行为都把`Humongous Region`作为老年代 的一部分来进行看待
	- 每次回收`Region`的整数倍。跟踪`Region`计算其价值，价值就是回收能获得的空间以及垃圾回收需要的时间的经验值。维护一个优先队列，回收器根据设定的停顿时间，去选择优先处理哪些区域。
- 细节
	- `Region`之间是复制算法，整体上是标记-压缩算法。
	- 每个`Region`通过指针碰撞来分配空间
	- 为每个`Region`设计了两个名为TAMS的指针，那`Region`中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收的新分配的对象地址都必须在这两个指针位置以上
	- TLAB还是用来保证并发性

### 参数设置
- `-XX:G1HeapReginSize`:设置每个`Region`的大小，默认是堆内存的1/2000。
- `-XX:MaxGCPauseMillis`：设置期望达到的最大GC停顿值

### G1优化常见步骤
1. 开启G1垃圾回收器
2. 设置堆的最大内存
3. 设置最大停顿时间

### 使用场景
1. 面向服务器应用，针对具有大内存、多处理器的机器
2. 需要低GC延迟，且具有大堆的应用程序
3. 替换CMS

### 详细流程
![[截屏2021-11-13 下午5.50.47.png]]
主要包括如下三个环节：
- 年轻代GC
- 老年代并发标记过程
- 混合回收Mixed GC
- 如果需要，`Full GC`

#### 流程
1. 应用程序分配内存，当年轻代`Eden`区用尽时开始年轻代回收过程；G1的年轻代收集是一个并行的独占式收集器。年轻代回收期间，暂停所有应用程序线程，启动多线程执行年轻代回收，然后从年轻代移动存活对象到`Survivor`或老年代，或两者都有
2. 当堆内存使用达到一定值(45%)，开始老年代并发标记过程
3. 标记完成，马上开始混合回收。混合回收期间，G1 GC从老年代移动存货对象到空闲区间，这些空闲区间也成了老年代的一部分。G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的`Region`就可以了。

#### G1回收器过程一：年轻代GC
1. JVM启动，程序在运行过程中不断创建对象到`Eden`区，当`Eden`区空间耗尽时，G1会启动一次年轻代垃圾回收过程
2. 年轻代只回收`Eden`和`Survivor`区
3. YGC时，G1先STW，创建回收集（`Collcection Set`），回收集指需要被回收的内存分段的集合。
##### 详细过程
1. 扫描根`GC Roots`，根引用连同RSet记录作为扫描对象的入口
2. 更新RSet
3. 处理RSet
4. 复制对象
	1. 将`Eden`和S0的存货对象复制到S1，如果年龄不到阈值，就+1，到阈值就再移动到老年区。S1空间不够，也会直接移到老年区。
5. 处理引用

#### G1回收器过程二：老年代并发标记阶段
1. 初始标记阶段：标记从根节点直接可达的对象，该阶段STW，且触发一次YGC。此时只扫描根节点可达的对象。
2. 根区域扫描：扫描S区直接可达的老年代区域对象，并标记被引用的对象，这一鬼哟成必须在YGC前完成。
3. 并发标记
	1. 在整个堆中进行并发标记，可能会被YGC中断
	2. 并发标记阶段，若发现区域对象中的所有对象都是垃圾，则这个区域会被立即回收。
	3. 该过程会计算每个区域的对象活性（存活对象比例）
4. 再次标记：修正上次标记结果，需STW。
5. 独占清理：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域，为下阶段做准备，该阶段STW，但不会进行垃圾收集
6. 并发清理阶段：识别并清理完全空闲的区域。

#### G1回收器过程三：混合回收过程
- 混合回合垃圾回收器除了回收整个年轻代，还回收部分老年代。
- 细节
	- 并发标记阶段结束以后，老年代中百分百为垃圾的内存被回收，部分为垃圾的内存被计算出来，这些老年代的内存会分8次被回收。
	- 由于老年代分8次回收，G1会优先回收垃圾多的内存分段。`-XX:G1MixedGCLiveThresholdPercent`决定垃圾占内存分段的百分比阈值，到达该阈值会被回收。

#### 过程四：Full GC
- 如果上述方式不能工作，G1会STW，使用单线程进行垃圾回收。
- 可能会导致Full GC的原因有两个
	- 复制时没有足够的空间存放晋升的对象
	- 并发处理过程完成之前空间耗尽

**G1 回收器的优化建议**

1.  年轻代大小
    -   避免使用-Xmn或-XX:NewRatio等相关选项显式设置年轻代大小，因为固定年轻代的大小会覆盖可预测的暂停时间目标。我们让G1自己去调整
2.  暂停时间目标不要太过严苛
    -   G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间
    -   评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。


## 垃圾回收器总
## GC日志分析

