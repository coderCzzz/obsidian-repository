## 引言
- 多个线程同时**读写**同一共享变量存在并发问题
	- 只有读没有写，是不会有并发问题的。
	- 因此就提供了一个解决并发问题的思路：让共享变量只有读操作，没有写操作，也就是**不变性模式**
- **不变性模式**：变量一旦被赋值，就不允许修改

## 如何实现一个具备不变性的类
- 将类的所有属性设置成`final`,且只允许存在只读方法，更严格可以将类设置成`final`，不允许被继承。因为子类可以覆盖父类的方法。
- `Java SDK`中的`String Long Integer Double`等都具有不可变性。这些对象的线程安全性都是靠不可变性来保证的。
- 如果需要修改，通过创建一个新的不可变对象来实现。因此这样会浪费内存。下面介绍使用[[享元模式]]避免创建重复对象。

## 利用享元模式避免创建重复对象
- `Long Integer Short Byte`等都用到了享元模式。
	- 一般不使用上面几个对象作为锁，因此可能是共享的。
- 享元模式：本质上是对象池。创建之前，先去对象池中看是不是存在，如果已存在，则直接返回，不存在再创建一个新的对象，再把这个新创建出来的对象放进内存池。

### Long类详解
- 内部维护一个静态的对象池，仅缓存`[-128, 127]`之间的数字，该对象池在JVM启动时就创建好了。

## 使用Immutability模式的注意事项
- 对象的所有属性都是`final`的，但是并不能保证不可变性
	- 下面的例子中，虽然`Bar`的属性`Foo`是`final`的，但是可以通过`setAge`修改`foo`的属性`age`
```
class Foo{
	int age = 0;
	String name = "adc";
}
final class Bar{
	final Foo foo;
	void setAge(int a) {
		foo.age = a;
	}
}
```
- 不可变对象也需要正确发布
	- 不可变对象是线程安全的，但是不能保证引用这些不可变对象的对象也是线程安全的--例子也是上面`Foo`的代码