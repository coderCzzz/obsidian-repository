## 什么是管程
- **管程** (英语：Monitors，也称为**监视器**) 是一种程序结构，结构内的多个子程序（对象)或模块形成的多个工作线程"工作 (信息学)")互斥访问共享资源。大白话就是一个程序代码模板，这个模块对共享变量进行管理，套用这个模板，可以互斥的访问共享资源。
- 管程共三个模型：Hasen模型、Hoare模型、MESA模型，Java参考MESA模型。
	- 三者的核心区别就是当条件满足后，如何通知相关线程
	- 管程要求同一时刻只允许一个线程执行，那么当线程T2的操作使线程T1的条件满足时，T1和T2谁执行
		- Hasen模型，`notifyAll()`放代码最后，这样T2执行完再通知T1
		- Hoare模型，T2通知T1后，T2阻塞，T1马上执行，执行完再唤醒T2
		- MESA模型，T2通知T1，T2继续执行，T1从条件变量的等待队列进入到入口的等待队列

### 管程如何解决互斥问题
- 互斥即同一时刻只允许一个线程访问共享资源。
- 管程思路
	- 将共享变量以及对共享变量的操作都封装起来，要访问操作共享变量，只能通过管程提供的方法。而管程提供的方法会保持互斥。

### 管程如何解决同步问题
- 同步即线程间如何通信、协作，说白了就是线程之间如何交流自己做完了，如何安排相对顺讯
- 类似就医，进入管程内部只有一个入口，多个线程在入口等待（入口等待队列），每次只允许一个线程进去，类似于挂号排队
- 线程进去后再看是否符合某种条件，管程将不同的条件抽象为条件变量，不同的条件变量对应不同的等待队列，不满足条件就到对应的等待队列等待，类似于见到医生，医生要去验血单，你没有就需要去抽血（跟后面联系不太恰当）。线程进入这个等待队列，允许其他线程进入管程--通过`wait()`实现
- 当某个条件满足后，管程会通知线程再次进入，但是线程此时要去入口的等待队列再排队--`notify()`、`notifyAll()`实现

### notify()何时可以使用
- 满足下列三个条件
1. 所有等待线程拥有相同的等待条件
2. 所有等待线程被唤醒后，执行相同的操作
3. 只需要唤醒一个线程

## MESA模型
- Java内置的管程中只有一个条件变量
![[截屏2021-12-17 上午11.15.57.png]]
- java内置的管程就是`synchronized`,被其修饰的代码块在编译器自动生成相关加锁和解锁代码，但仅支持一个条件变量。