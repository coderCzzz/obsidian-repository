## 解决可见性和有序性问题思路
- 直接粗暴禁止使用缓存和编译优化。--会带来性能问题
- 合理方案：按需禁用缓存和编译优化。那么如何按需禁用呢：程序员自己判断

## volatile关键字
- 语义即禁用缓存。如果声明变量为`volatile`，则代表对这个变量的读写，不能使用cpu缓存，必须直接从内存中读取或写入。
- 代码案例：下面代码中，如果线程A调用了`write`方法，会将`v=true`写入内存。如果线程B执行`read`方法，需要从内存中读取`v=ture`，但是x没有禁用缓存，此时x是多少呢？
	- `java <1.5`v可能是0，也可能是42,`>1.5`，则是42，通过`Happens-Before`对`volatile`进行了增强
```java
class VolatileExample {
	int x = 0;
	volatile boolean v = false;
	public void write() {
		x= 42;
		v =true;
	}
	publiv void read() {
		if (v = true) {
			x = ?
		}
	}
}
```

## Happens-Before
- 即前一个操作的结果对后续操作是可见的。约束了编译器的优化行为。

### 程序的顺序性规则
- 指在一个线程中，按照程序顺序，前面的操作HB于后续的任意操作
- 上述代码中即`x = 42`对于`v=true`是可见的

### volatile变量规则
- 一个`volatile`变量的写规则，可见于后续对这个`volatile`的读操作
- 上述代码中，线程A`v=true`这个写操作就可见于线程B的`v=true`这个读操作

###  传递性
- 如果A可见于B，B可见于C，则A可见于C
- 上述代码`x=42`可见于线程A的`v=true`写操作，线程A`v=true`这个写操作就可见于线程B的`v=true`这个读操作,因此利用传递性，`x=42`可见于线程B的`v=true`这个读操作

### 管程中锁的规则
- 一个锁的解锁可见于后续对这个锁的加锁

### 线程start()规则
- 主线程A启动子线程B后，子线程B能够看到主线程在启动子线程B前的操作

### 线程join()规则
- 主线程A等待子线程B完成，当子线程B完成后，主线程能够看到子线程的操作，看到指对共享变量的操作

### 线程中断规则

### 对象终结规则

## final



