## 概述
`Lock`和`Condition`两个接口实现了管程

### Synchronized已经实现了管程，为什么还要Lock
- 死锁的解决方案中有一个“破坏不可抢占条件”：占用资源的线程进一步申请其他资源时，申请不到，就主动释放自己占有的资源。
- `synchronized`无法做到，`synchronized`申请资源时，如果申请不到，则线程进入阻塞，而线程进入阻塞，什么都做不了。
- 我们重新设计一把锁，有三种方案
	- 能够响应中断
		- `synchronized`的问题在于阻塞之后，如果死锁了，就再也没有机会被唤醒了。因此如果我们能够唤醒它，它就可以释放自己的锁，就破坏了不可抢占条件了
	- 支持超时
		- 如果线程一段时间之内没有获取到锁，此时不进入阻塞，而是返回一个错误，则线程也有机会释放曾经持有的锁
	- 非阻塞地获取锁
		- 尝试获取锁失败，不进入阻塞状态，而是直接返回。
		- 以上三种方案，就体现在`Lock`的三个方法上
			- `void lockInterruptibly() throws InterruptedException;`
			- `boolean tryLock(long time, TimeUnit unit)throws InterruptedException`
			- `boolean tryLock()`

### Lock
- 使用`Lock`需要自己加锁、解锁。
- `Lock`的可见性
	- 结论：利用`volatile`相关的`Happens-Before`规则保证了可见性。
```
class SampleLock {

volatile int state;

	// 加锁

	lock() {

	// 省略代码无数

	state = 1;

	}

	// 解锁

	unlock() {

	// 省略代码无数

	state = 0;

	}

}
```

### 可重入锁ReentrantLock
- 可重入锁:线程可以重复获取同一把锁。假如线程T1获取了锁a（或加锁），如果下次再在其他地方需要对加锁a，如果是可重复锁，则加锁成功，不是则阻塞。

### 公平锁与非公平锁
线程在等待获取锁时，会进入等待队列，当有线程释放锁时，需要从等待队列中唤醒一个等待的线程。如果是公平锁，唤醒的策略就是谁等待的时间长。

### 用锁的最佳实践
- 永远只在更新对象的成员变量时加锁
- 永远只在访问可变的成员变量时加锁
- 永远不在调用其他对象的方法时加锁


## Condition
`Lock`和`Condition`实现了管程。
在[[管程#管程如何解决同步问题]]中，我们知道，线程在进入临界区时需要在等待队列中等待，每次只允许一个线程进入临界区，进入临界区后，需要再判断是否满足某种条件，不满足的话，进入对应条件的等待队列，当条件满足再被唤醒。
- `Condition`对应管程中的多个条件变量，弥补了`synchronized`只有一个条件变量的缺点。
- `await() notify() notifyAll()`只能在`synchronized`使用，而`await()、signal()、signalAll()`是`Condition`对应的方法


## 如何在java中实现异步
两种方式：
1. 调用方创建一个子线程，在子线程中执行方法调用，我们称之为异步调用
2. 方法实现的时候，创建一个新的线程执行主要逻辑，主线程直接return，称为异步方法。

### RPC异步转同步
当RPC返回结果之前，阻塞调用线程，让调用线程等待；当RPC返回结果后，唤醒调用线程，让线程重新执行。--等待-通知机制。
